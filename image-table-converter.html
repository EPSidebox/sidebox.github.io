<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image â†” Table Converter</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-8XQLL5N022"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-8XQLL5N022');
  </script>

<meta name="citation_title" content="Image-Table Converter">
<meta name="citation_author" content="PeÃ±a, Ernesto">
<meta name="citation_publication_date" content="2026/01/08">
<meta name="citation_technical_report_institution" content="Northeastern University">
<meta name="citation_technical_report_number" content="v1.0">
<meta name="citation_abstract" content="A browser-based tool for converting images to Excel spreadsheets and back to raw data. Each colour channel becomes a separate sheet with pixel values as cells, enabling databending through spreadsheet manipulation.">
<meta name="citation_keywords" content="databending; image processing; spreadsheet; xlsx; raw data; glitch art">
<meta name="citation_public_url" content="https://epsidebox.github.io/sidebox.github.io/image-table-converter.html">

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareApplication",
  "name": "Image-Table Converter",
  "author": {
    "@type": "Person",
    "name": "Ernesto PeÃ±a",
    "affiliation": "Northeastern University",
    "url": "https://ernestopena.com"
  },
  "datePublished": "2026-01-08",
  "version": "1.0",
  "description": "A browser-based tool for converting images to Excel spreadsheets and back to raw data. Each color channel becomes a separate sheet with pixel values as cells, enabling databending through spreadsheet manipulation.",
  "url": "https://epsidebox.github.io/sidebox.github.io/image-table-converter.html",
  "applicationCategory": "EducationalApplication",
  "operatingSystem": "Web browser",
  "keywords": ["databending", "image processing", "spreadsheet", "xlsx", "raw data", "glitch art"]
}
</script>
  <style>
    /* === BASE RESET === */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    /* === TYPOGRAPHY & COLORS === */
    :root {
      --font: 'Roboto Mono', monospace;
      --bg: #ffffff;
      --text: #000000;
      --accent: #FF00FF;
      --accent-secondary: #00bcd4;
      --accent-tertiary: #8bc34a;
      --muted: #666;
      --border: #000;
      --panel-bg: #fafafa;
      --hover-bg: #f5f5f5;
      --hover-text: #000;
      --input-bg: #fff;
      --warning-bg: #fff3cd;
      --cell-border: #eee;
    }
    
    [data-theme="dark"] {
      --bg: #0a0a0a;
      --text: #e0e0e0;
      --accent: #FF00FF;
      --accent-secondary: #00bcd4;
      --accent-tertiary: #8bc34a;
      --muted: #666;
      --border: #222;
      --panel-bg: #111;
      --hover-bg: #1a1a1a;
      --hover-text: #fff;
      --input-bg: #1a1a1a;
      --warning-bg: #443300;
      --cell-border: #333;
    }
    
    body {
      font-family: 'Roboto Mono', monospace;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: clamp(1rem, 1rem + ((1vw - 0.48rem) * 0.288), 1.125rem);
      line-height: 1.6;
      font-size: clamp(0.875rem, 0.875rem + ((1vw - 0.48rem) * 0.288), 1rem);
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    header {
      margin-bottom: clamp(1rem, 1rem + ((1vw - 0.48rem) * 0.288), 1.125rem);
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      flex-wrap: wrap;
      gap: 12px;
    }
    
    .header-content {
      flex: 1;
      min-width: 200px;
    }
    
    h1 {
      color: var(--accent);
      font-size: clamp(1.75rem, 1.75rem + ((1vw - 0.48rem) * 0.288), 1.875rem);
      margin-bottom: 4px;
      font-weight: 400;
      line-height: 1.2;
    }
    
    .subtitle {
      color: var(--muted);
      font-size: clamp(0.8125rem, 0.8125rem + ((1vw - 0.48rem) * 0.144), 0.875rem);
      line-height: 1.5;
    }
    
    .theme-toggle {
      padding: 6px 12px;
      background: var(--panel-bg);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      cursor: pointer;
      font-family: inherit;
      font-size: clamp(0.625rem, 0.625rem + ((1vw - 0.48rem) * 0.072), 0.6563rem);
      transition: all 0.15s;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .theme-toggle:hover {
      border-color: var(--accent);
      background: var(--hover-bg);
    }
    
    .theme-toggle:focus {
      outline: 2px dashed var(--accent);
      outline-offset: 2px;
    }
    
    .section {
      background: var(--panel-bg);
      border: 1px solid var(--border);
      padding: 24px;
      margin-bottom: 1.5rem;
      border-radius: 6px;
    }
    
    .section h2 {
      color: var(--accent);
      font-size: clamp(0.875rem, 0.875rem + ((1vw - 0.48rem) * 0.144), 0.9375rem);
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 16px;
      line-height: 1.4;
    }
    
    .section p {
      font-size: clamp(0.6875rem, 0.6875rem + ((1vw - 0.48rem) * 0.072), 0.7188rem);
      line-height: 1.5;
      color: var(--muted);
      margin-bottom: 16px;
    }
    
    .row {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }
    
    .row:last-child { margin-bottom: 0; }
    
    label {
      font-size: clamp(0.6875rem, 0.6875rem + ((1vw - 0.48rem) * 0.072), 0.7188rem);
      font-weight: 500;
      color: var(--text);
    }
    
    input[type="file"] {
      font-family: 'Roboto Mono', monospace;
      font-size: clamp(0.625rem, 0.625rem + ((1vw - 0.48rem) * 0.072), 0.6563rem);
      color: var(--text);
    }
    
    select {
      padding: 8px;
      background: var(--bg);
      color: var(--text);
      border: 1px solid var(--border);
      font-family: 'Roboto Mono', monospace;
      font-size: clamp(0.6875rem, 0.6875rem + ((1vw - 0.48rem) * 0.072), 0.7188rem);
      border-radius: 3px;
      transition: border-color 0.15s;
    }
    
    select:hover {
      border-color: var(--accent);
    }
    
    select:focus {
      outline: none;
      border-color: var(--accent);
    }
    
    button {
      padding: 10px 16px;
      background: var(--bg);
      color: var(--text);
      border: 1px solid var(--border);
      font-family: 'Roboto Mono', monospace;
      font-size: clamp(0.625rem, 0.625rem + ((1vw - 0.48rem) * 0.072), 0.6563rem);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      cursor: pointer;
      transition: all 0.15s;
      border-radius: 3px;
    }
    
    button:hover:not(:disabled) {
      background: var(--text);
      color: var(--bg);
    }
    
    button:focus {
      outline: 2px dashed var(--accent);
      outline-offset: 2px;
    }
    
    button:active:not(:disabled) {
      transform: scale(0.98);
    }
    
    button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    
    button:disabled:hover {
      background: var(--bg);
      color: var(--text);
    }
    
    button.primary {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
    }
    
    button.primary:hover:not(:disabled) {
      background: #cc00cc;
      border-color: #cc00cc;
    }
    
    button.primary:disabled {
      background: var(--accent);
      opacity: 0.4;
    }
    
    button.primary:disabled:hover {
      background: var(--accent);
      color: var(--bg);
    }
    
    .warning {
      background: var(--warning-bg);
      border: 1px solid var(--border);
      padding: 12px;
      font-size: clamp(0.6875rem, 0.6875rem + ((1vw - 0.48rem) * 0.072), 0.7188rem);
      margin: 12px 0;
      display: none;
      border-radius: 4px;
    }
    
    .warning.show { display: block; }
    
    .warning p {
      color: var(--text);
      margin-bottom: 8px;
      line-height: 1.5;
    }
    
    .info {
      font-size: clamp(0.625rem, 0.625rem + ((1vw - 0.48rem) * 0.072), 0.6563rem);
      color: var(--muted);
      margin-top: 8px;
      line-height: 1.4;
    }
    
    .preview {
      margin-top: 16px;
      max-width: 100%;
      overflow: auto;
      border: 1px solid var(--border);
      padding: 8px;
      display: none;
      border-radius: 4px;
      background: var(--bg);
    }
    
    .preview.show { display: block; }
    
    .preview img {
      max-width: 320px;
      height: auto;
      image-rendering: pixelated;
    }
    
    .preview-info {
      font-size: clamp(0.625rem, 0.625rem + ((1vw - 0.48rem) * 0.072), 0.6563rem);
      color: var(--muted);
      margin-top: 8px;
    }
    
    .channel-item {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border: 1px solid var(--border);
      margin-right: 8px;
      margin-bottom: 8px;
      cursor: grab;
      background: var(--bg);
      font-size: clamp(0.6875rem, 0.6875rem + ((1vw - 0.48rem) * 0.072), 0.7188rem);
      border-radius: 3px;
      transition: all 0.15s;
    }
    
    .channel-item:hover {
      border-color: var(--accent);
    }
    
    .channel-item:active {
      cursor: grabbing;
    }
    
    .channel-item.dragging {
      opacity: 0.5;
    }
    
    .channel-item input {
      width: 60px;
      padding: 4px;
      border: 1px solid var(--border);
      font-family: 'Roboto Mono', monospace;
      font-size: clamp(0.625rem, 0.625rem + ((1vw - 0.48rem) * 0.072), 0.6563rem);
      background: var(--input-bg);
      color: var(--text);
      border-radius: 3px;
      transition: border-color 0.15s;
    }
    
    .channel-item input:hover {
      border-color: var(--accent);
    }
    
    .channel-item input:focus {
      outline: none;
      border-color: var(--accent);
    }
    
    .preview-tabs {
      display: flex;
      gap: 0;
    }
    
    .preview-tab {
      padding: 8px 16px;
      border: 1px solid var(--border);
      border-bottom: none;
      background: var(--bg);
      font-size: clamp(0.625rem, 0.625rem + ((1vw - 0.48rem) * 0.072), 0.6563rem);
      cursor: pointer;
      margin-right: -1px;
      transition: all 0.15s;
      border-radius: 4px 4px 0 0;
    }
    
    .preview-tab:hover {
      background: var(--hover-bg);
      color: var(--accent);
    }
    
    .preview-tab:focus {
      outline: 2px dashed var(--accent);
      outline-offset: -2px;
    }
    
    .preview-tab.active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
    }
    
    .preview-grid {
      display: grid;
      font-size: clamp(0.5625rem, 0.5625rem + ((1vw - 0.48rem) * 0.072), 0.5938rem);
      border: 1px solid var(--border);
      border-top: none;
    }
    
    .preview-cell {
      padding: 4px 6px;
      border-right: 1px solid var(--cell-border);
      border-bottom: 1px solid var(--cell-border);
      text-align: center;
      min-width: 32px;
      background: var(--bg);
    }
    
    footer {
      margin-top: clamp(1.5rem, 1.5rem + ((1vw - 0.48rem) * 1.442), 2rem);
      padding-top: 14px;
      border-top: 1px solid var(--border);
      font-size: clamp(0.625rem, 0.625rem + ((1vw - 0.48rem) * 0.072), 0.6563rem);
      color: var(--muted);
      text-align: center;
      line-height: 1.6;
    }

    footer a {
      color: var(--accent);
      text-decoration: underline;
      transition: all 0.15s;
    }
    
    footer a:hover {
      text-decoration: none;
      color: var(--hover-text);
    }
    
    footer a:focus {
      text-decoration: underline dashed;
      outline: 2px dashed var(--accent);
      outline-offset: 2px;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div class="header-content">
        <h1>Image â†” Table Converter</h1>
        <p class="subtitle">Convert images to spreadsheets and back for databending</p>
      </div>
      <button class="theme-toggle" id="themeToggle" aria-label="Toggle theme">
        <span id="themeIcon">ðŸŒ™</span>
        <span id="themeText">Dark</span>
      </button>
    </header>
    
    <main>
      <!-- IMAGE TO TABLE -->
      <div class="section">
        <h2>Image â†’ Table (.xlsx)</h2>
        <p>Convert an image to a spreadsheet with one byte per cell. Each channel (R, G, B, A) gets its own sheet.</p>
        
        <div class="row">
          <input type="file" id="imgInput" accept="image/*">
        </div>
        
        <div class="warning" id="imgWarning">
          <p>âš  Image exceeds 640Ã—640 pixels. It will be resized to fit within this limit.</p>
          <button id="resizeBtn">Resize and Continue</button>
        </div>
        
        <div class="preview" id="imgPreview">
          <img id="previewImg">
          <div class="preview-info" id="imgInfo"></div>
        </div>
        
        <div class="row" style="margin-top:16px;">
          <button class="primary" id="exportXlsxBtn" disabled>Export .xlsx</button>
        </div>
      </div>
      
      <!-- TABLE TO RAW -->
      <div class="section">
        <h2>Table â†’ Raw</h2>
        <p>Convert an .xlsx spreadsheet back to a headerless .raw file. Each sheet should contain one channel.</p>
        
        <div class="row">
          <input type="file" id="xlsxInput" accept=".xlsx,.xls">
        </div>
        
        <div class="row">
          <label>Channel Order:</label>
          <select id="channelOrder">
            <option value="planar">Planar (RRRR...GGGG...BBBB...)</option>
            <option value="interleaved">Interleaved (RGBRGBRGB...)</option>
          </select>
        </div>
        
        <div class="info" id="xlsxInfo"></div>
        
        <div id="channelConfig" style="display:none;margin-top:16px;">
          <label style="display:block;margin-bottom:8px;">Channel order (drag to reorder):</label>
          <div id="channelList"></div>
        </div>
        
        <div id="xlsxPreview" style="display:none;margin-top:16px;">
          <label style="display:block;margin-bottom:8px;">Preview (top-left 8Ã—8):</label>
          <div id="previewTabs"></div>
          <div id="previewTable" style="overflow:auto;max-height:200px;margin-top:8px;"></div>
        </div>
        
        <div class="row" style="margin-top:16px;">
          <button class="primary" id="exportRawBtn" disabled>Export .raw</button>
        </div>
      </div>
    </main>

    <footer>
      Image â†” Table Converter â€” A Glitch Pedagogy Tool<br>
      Created by Ernesto PeÃ±a | <a href="https://ernestopena.com" target="_blank">ernestopena.com</a>
    </footer>
  </div>

  <script>
    // === THEME TOGGLE ===
    const themeToggle = document.getElementById('themeToggle');
    const themeIcon = document.getElementById('themeIcon');
    const themeText = document.getElementById('themeText');
    const html = document.documentElement;
    
    const getPreferredTheme = () => {
      const savedTheme = localStorage.getItem('theme');
      if (savedTheme) return savedTheme;
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    
    const setTheme = (theme) => {
      if (theme === 'dark') {
        html.setAttribute('data-theme', 'dark');
        themeIcon.textContent = 'â˜€ï¸';
        themeText.textContent = 'Light';
      } else {
        html.removeAttribute('data-theme');
        themeIcon.textContent = 'ðŸŒ™';
        themeText.textContent = 'Dark';
      }
      localStorage.setItem('theme', theme);
    };
    
    setTheme(getPreferredTheme());
    
    themeToggle.addEventListener('click', () => {
      const currentTheme = html.getAttribute('data-theme');
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
      setTheme(newTheme);
    });
    
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
      if (!localStorage.getItem('theme')) {
        setTheme(e.matches ? 'dark' : 'light');
      }
    });

    // === IMAGE TO TABLE ===
    const imgInput = document.getElementById('imgInput');
    const imgWarning = document.getElementById('imgWarning');
    const resizeBtn = document.getElementById('resizeBtn');
    const imgPreview = document.getElementById('imgPreview');
    const previewImg = document.getElementById('previewImg');
    const imgInfo = document.getElementById('imgInfo');
    const exportXlsxBtn = document.getElementById('exportXlsxBtn');
    
    let currentImg = null;
    let needsResize = false;
    let imgData = null;
    
    const MAX_DIM = 640;
    
    imgInput.addEventListener('change', e => {
      const file = e.target.files[0];
      if (!file) return;
      
      const img = new Image();
      img.onload = () => {
        currentImg = img;
        needsResize = img.width > MAX_DIM || img.height > MAX_DIM;
        
        if (needsResize) {
          imgWarning.classList.add('show');
          imgPreview.classList.remove('show');
          exportXlsxBtn.disabled = true;
          imgData = null;
        } else {
          imgWarning.classList.remove('show');
          processImage(img, img.width, img.height);
        }
      };
      img.src = URL.createObjectURL(file);
    });
    
    resizeBtn.addEventListener('click', () => {
      if (!currentImg) return;
      let w = currentImg.width, h = currentImg.height;
      const scale = Math.min(MAX_DIM / w, MAX_DIM / h);
      w = Math.floor(w * scale);
      h = Math.floor(h * scale);
      imgWarning.classList.remove('show');
      processImage(currentImg, w, h);
    });
    
    function processImage(img, w, h) {
      const canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, w, h);
      imgData = ctx.getImageData(0, 0, w, h);
      
      previewImg.src = canvas.toDataURL();
      const hasAlpha = checkAlpha(imgData.data);
      imgInfo.textContent = `${w}Ã—${h} pixels | ${hasAlpha ? 'RGBA' : 'RGB'} | ${w * h * (hasAlpha ? 4 : 3)} bytes`;
      imgPreview.classList.add('show');
      exportXlsxBtn.disabled = false;
    }
    
    function checkAlpha(data) {
      for (let i = 3; i < data.length; i += 4) {
        if (data[i] < 255) return true;
      }
      return false;
    }
    
    exportXlsxBtn.addEventListener('click', () => {
      if (!imgData) return;
      
      const w = imgData.width, h = imgData.height;
      const data = imgData.data;
      const hasAlpha = checkAlpha(data);
      
      const channels = { R: [], G: [], B: [] };
      if (hasAlpha) channels.A = [];
      
      for (let y = 0; y < h; y++) {
        const rowR = [], rowG = [], rowB = [], rowA = [];
        for (let x = 0; x < w; x++) {
          const i = (y * w + x) * 4;
          rowR.push(data[i]);
          rowG.push(data[i + 1]);
          rowB.push(data[i + 2]);
          if (hasAlpha) rowA.push(data[i + 3]);
        }
        channels.R.push(rowR);
        channels.G.push(rowG);
        channels.B.push(rowB);
        if (hasAlpha) channels.A.push(rowA);
      }
      
      const wb = XLSX.utils.book_new();
      for (const [name, rows] of Object.entries(channels)) {
        const ws = XLSX.utils.aoa_to_sheet(rows);
        XLSX.utils.book_append_sheet(wb, ws, name);
      }
      
      XLSX.writeFile(wb, 'image_channels.xlsx');
    });
    
    // === TABLE TO RAW ===
    const xlsxInput = document.getElementById('xlsxInput');
    const channelOrder = document.getElementById('channelOrder');
    const xlsxInfo = document.getElementById('xlsxInfo');
    const exportRawBtn = document.getElementById('exportRawBtn');
    const channelConfig = document.getElementById('channelConfig');
    const channelList = document.getElementById('channelList');
    const xlsxPreview = document.getElementById('xlsxPreview');
    const previewTabs = document.getElementById('previewTabs');
    const previewTable = document.getElementById('previewTable');
    
    let xlsxData = null;
    let channelNames = [];
    let activePreviewTab = null;
    
    xlsxInput.addEventListener('change', e => {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = ev => {
        const data = new Uint8Array(ev.target.result);
        const wb = XLSX.read(data, { type: 'array' });
        
        xlsxData = {};
        channelNames = wb.SheetNames.slice();
        let dims = null;
        
        for (const name of wb.SheetNames) {
          const ws = wb.Sheets[name];
          const arr = XLSX.utils.sheet_to_json(ws, { header: 1 });
          xlsxData[name] = arr;
          
          if (!dims && arr.length > 0) {
            dims = { h: arr.length, w: arr[0].length };
          }
        }
        
        xlsxInfo.textContent = `${channelNames.length} channel(s) | ${dims ? dims.w + 'Ã—' + dims.h : 'empty'}`;
        
        renderChannelList();
        renderPreviewTabs();
        if (channelNames.length > 0) {
          showPreview(channelNames[0]);
        }
        
        channelConfig.style.display = 'block';
        xlsxPreview.style.display = 'block';
        exportRawBtn.disabled = false;
      };
      reader.readAsArrayBuffer(file);
    });
    
    function renderChannelList() {
      channelList.innerHTML = '';
      channelNames.forEach((name, idx) => {
        const item = document.createElement('div');
        item.className = 'channel-item';
        item.draggable = true;
        item.dataset.idx = idx;
        
        const label = document.createElement('span');
        label.textContent = (idx + 1) + '.';
        
        const input = document.createElement('input');
        input.type = 'text';
        input.value = name;
        input.addEventListener('change', () => {
          const oldName = channelNames[idx];
          const newName = input.value.trim() || oldName;
          if (newName !== oldName && xlsxData[oldName]) {
            xlsxData[newName] = xlsxData[oldName];
            delete xlsxData[oldName];
            channelNames[idx] = newName;
            renderPreviewTabs();
            if (activePreviewTab === oldName) showPreview(newName);
          }
        });
        
        item.appendChild(label);
        item.appendChild(input);
        channelList.appendChild(item);
        
        item.addEventListener('dragstart', handleDragStart);
        item.addEventListener('dragover', handleDragOver);
        item.addEventListener('drop', handleDrop);
        item.addEventListener('dragend', handleDragEnd);
      });
    }
    
    let dragIdx = null;
    
    function handleDragStart(e) {
      dragIdx = +this.dataset.idx;
      this.classList.add('dragging');
    }
    
    function handleDragOver(e) {
      e.preventDefault();
    }
    
    function handleDrop(e) {
      e.preventDefault();
      const dropIdx = +this.dataset.idx;
      if (dragIdx !== null && dragIdx !== dropIdx) {
        const moved = channelNames.splice(dragIdx, 1)[0];
        channelNames.splice(dropIdx, 0, moved);
        renderChannelList();
        renderPreviewTabs();
      }
    }
    
    function handleDragEnd() {
      this.classList.remove('dragging');
      dragIdx = null;
    }
    
    function renderPreviewTabs() {
      previewTabs.innerHTML = '';
      previewTabs.className = 'preview-tabs';
      channelNames.forEach(name => {
        const tab = document.createElement('div');
        tab.className = 'preview-tab' + (name === activePreviewTab ? ' active' : '');
        tab.textContent = name;
        tab.addEventListener('click', () => showPreview(name));
        previewTabs.appendChild(tab);
      });
    }
    
    function showPreview(name) {
      activePreviewTab = name;
      renderPreviewTabs();
      
      const rows = xlsxData[name] || [];
      const previewRows = 8, previewCols = 8;
      
      let html = '<div class="preview-grid" style="grid-template-columns: repeat(' + Math.min(previewCols, (rows[0]?.length || 0)) + ', 1fr);">';
      for (let y = 0; y < Math.min(previewRows, rows.length); y++) {
        for (let x = 0; x < Math.min(previewCols, rows[y]?.length || 0); x++) {
          const val = rows[y][x] ?? '';
          html += '<div class="preview-cell">' + val + '</div>';
        }
      }
      html += '</div>';
      previewTable.innerHTML = html;
    }
    
    exportRawBtn.addEventListener('click', () => {
      if (!xlsxData || channelNames.length === 0) return;
      
      const order = channelOrder.value;
      
      const first = xlsxData[channelNames[0]];
      const h = first.length;
      const w = first[0]?.length || 0;
      
      let rawBytes;
      
      if (order === 'planar') {
        const totalBytes = channelNames.length * w * h;
        rawBytes = new Uint8Array(totalBytes);
        let offset = 0;
        
        for (const ch of channelNames) {
          const rows = xlsxData[ch];
          for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
              rawBytes[offset++] = rows[y]?.[x] ?? 0;
            }
          }
        }
      } else {
        const totalBytes = channelNames.length * w * h;
        rawBytes = new Uint8Array(totalBytes);
        let offset = 0;
        
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            for (const ch of channelNames) {
              rawBytes[offset++] = xlsxData[ch][y]?.[x] ?? 0;
            }
          }
        }
      }
      
      const blob = new Blob([rawBytes], { type: 'application/octet-stream' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'output.raw';
      a.click();
      URL.revokeObjectURL(url);
    });
  </script>
</body>
</html>

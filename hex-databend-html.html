<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Protected Hex Editor</title>

<!-- Zotero Metadata -->
<meta name="citation_title" content="Protected Hex Editor: Header-Safe Hex Editing for Image Databending">
<meta name="citation_author" content="Peña, Ernesto">
<meta name="citation_publication_date" content="2025">
<meta name="citation_online_date" content="2025-01-19">
<meta name="DC.title" content="Protected Hex Editor: Header-Safe Hex Editing for Image Databending">
<meta name="DC.creator" content="Ernesto Peña">
<meta name="DC.date" content="2025-01-19">
<meta name="DC.type" content="Software">
<meta name="DC.format" content="text/html">
<meta name="DC.language" content="en">
<meta name="description" content="Educational hex editor tool for glitch art pedagogy supporting JPEG, PNG, GIF, WebP, BMP, and TIFF formats with protected header regions, multi-select capabilities, and GIF frame navigation.">
<meta name="keywords" content="hex editor, databending, glitch art, image manipulation, digital art, pedagogy, educational tool">

<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8XQLL5N022"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-8XQLL5N022');
</script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
:root {
  --bg: #0a0a0a;
  --bg-panel: #0d0d0d;
  --fg: #e0e0e0;
  --fg-dim: #666666;
  --accent: #ff00ff;
  --protected: #ff6b9d;
  --editable: #9dff6b;
  --cursor: #ffff00;
  --border: #1a1a1a;
}
body {
  font-family: 'Roboto Mono', monospace;
  background: var(--bg);
  color: var(--fg);
  min-height: 100vh;
  padding: 24px;
}
.container { max-width: 1600px; margin: 0 auto; }
h1 { color: var(--accent); font-size: 24px; margin-bottom: 4px; }
.subtitle { color: var(--fg-dim); font-size: 12px; margin-bottom: 24px; }
.controls { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; margin-bottom: 24px; }
.btn {
  font-family: 'Roboto Mono', monospace;
  padding: 8px 16px;
  font-size: 12px;
  border: 1px solid var(--accent);
  background: transparent;
  color: var(--accent);
  cursor: pointer;
  transition: all 150ms;
}
.btn:hover { background: var(--accent); color: var(--bg); }
.btn:disabled { opacity: 0.3; cursor: default; }
.btn:disabled:hover { background: transparent; color: var(--accent); }
.btn-secondary { border-color: var(--fg-dim); color: var(--fg-dim); }
.btn-secondary:hover { border-color: var(--fg); color: var(--fg); background: transparent; }
.btn-action { border-color: var(--editable); color: var(--editable); }
.btn-action:hover { background: var(--editable); color: var(--bg); }
.btn-small { padding: 4px 8px; font-size: 10px; }
.file-info { margin-left: auto; font-size: 12px; color: var(--fg-dim); }
.file-info .format { color: var(--accent); }
.file-info .editable { color: var(--editable); }
.panel {
  background: var(--bg-panel);
  border: 1px solid var(--border);
  padding: 16px;
  margin-bottom: 16px;
}
.panel-title {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  color: var(--accent);
  margin-bottom: 12px;
}
.main-layout { display: grid; grid-template-columns: 220px minmax(520px, 1fr) 280px; gap: 16px; }
.structure-panel { 
  max-height: 800px; 
  overflow-y: scroll; 
}
.structure-panel::-webkit-scrollbar {
  width: 12px;
}
.structure-panel::-webkit-scrollbar-track {
  background: var(--bg-panel);
  border-left: 1px solid var(--border);
}
.structure-panel::-webkit-scrollbar-thumb {
  background: var(--fg-dim);
  border-radius: 2px;
}
.structure-panel::-webkit-scrollbar-thumb:hover {
  background: var(--accent);
}
.structure-item {
  padding: 8px;
  border-left: 2px solid var(--protected);
  margin-top: 8px;
  cursor: pointer;
  transition: background 150ms;
}
.structure-item:hover { background: rgba(255,255,255,0.05); }
.structure-item.editable { border-color: var(--editable); }
.structure-item .desc { font-size: 12px; }
.structure-item .offset { font-size: 11px; color: var(--fg-dim); margin-top: 2px; }
.hex-panel { position: relative; }
.hex-wrapper {
  display: flex;
  gap: 0;
}
.hex-container {
  background: #000;
  color: var(--fg);
  padding: 8px;
  border-radius: 4px 0 0 4px;
  font-family: 'Roboto Mono', monospace;
  font-size: 0.62rem;
  overflow: hidden;
  height: 520px;
  position: relative;
  flex: 1;
}
.hex-row {
  display: flex;
  gap: 6px;
  margin-bottom: 2px;
  padding: 2px 0;
  height: 17px;
}
.hex-row:hover { background: #1a1a1a; }
.hex-offset {
  color: #666;
  width: 52px;
  flex-shrink: 0;
  font-size: 0.6rem;
}
.hex-bytes {
  display: flex;
  gap: 3px;
  flex-shrink: 0;
  width: 461px;
  flex-wrap: nowrap;
}
.hex-byte {
  width: 26px;
  text-align: center;
  background: transparent;
  border: none;
  color: var(--fg);
  font-family: inherit;
  font-size: 10px;
  cursor: pointer;
  padding: 0;
  outline: none;
}
.hex-byte:hover { background: #333; }
.hex-byte:focus { outline: 2px solid var(--cursor); }
.hex-byte.selected {
  background: var(--accent);
  color: var(--bg);
  font-weight: bold;
}
.hex-byte-protected {
  background: #1a1a2a !important;
  color: #666 !important;
  cursor: not-allowed !important;
  opacity: 0.6;
}
.hex-byte-editable { color: var(--editable); }
.hex-ascii {
  color: #666;
  margin-left: 4px;
  flex-shrink: 0;
  font-size: 0.62rem;
}
.hex-scrollbar {
  width: 14px;
  background: #1a1a1a;
  border: 1px solid var(--border);
  border-left: none;
  border-radius: 0 4px 4px 0;
  height: 520px;
  position: relative;
  cursor: pointer;
  flex-shrink: 0;
}
.hex-scrollbar-thumb {
  position: absolute;
  width: 100%;
  background: var(--fg-dim);
  min-height: 20px;
  transition: background 150ms;
  left: 0;
  display: none;
}
.hex-scrollbar-thumb:hover,
.hex-scrollbar-thumb.dragging {
  background: var(--accent);
}
.legend { display: flex; gap: 16px; font-size: 12px; margin-bottom: 12px; }
.legend-protected { color: var(--protected); }
.legend-editable { color: var(--editable); }
.hex-status { margin-top: 12px; font-size: 12px; color: var(--fg-dim); }
.hex-status .pos { color: var(--accent); }
.hex-status .status-editable { color: var(--editable); }
.hex-status .status-locked { color: var(--protected); }
.preview-box {
  margin-top: 8px;
  height: 220px;
  background: var(--bg);
  border: 1px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: auto;
}
.preview-box img { object-fit: contain; image-rendering: pixelated; }
.preview-box img.zoom-1x { max-width: 100%; max-height: 100%; }
.preview-box img.zoom-2x { max-width: none; max-height: none; transform: scale(2); transform-origin: top left; }
.preview-box img.zoom-4x { max-width: none; max-height: none; transform: scale(4); transform-origin: top left; }
.preview-error { text-align: center; padding: 16px; }
.preview-error .icon { color: var(--protected); font-size: 14px; }
.preview-error .msg { color: var(--fg-dim); font-size: 11px; margin-top: 4px; }
.preview-controls { display: flex; gap: 8px; margin-top: 12px; align-items: center; }
.zoom-btn {
  font-family: 'Roboto Mono', monospace;
  padding: 4px 8px;
  font-size: 10px;
  border: 1px solid var(--border);
  background: transparent;
  color: var(--fg-dim);
  cursor: pointer;
  transition: all 150ms;
}
.zoom-btn:hover, .zoom-btn.active { border-color: var(--accent); color: var(--accent); }
.field-label {
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--fg-dim);
  margin: 12px 0 6px 0;
}
.ctrl-row {
  display: flex;
  gap: 4px;
}
.ctrl-row button {
  flex: 1;
  padding: 6px;
  font-size: 10px;
}
input[type="text"], input[type="number"] {
  width: 100%;
  padding: 6px;
  font-family: 'Roboto Mono', monospace;
  font-size: 10px;
  background: var(--bg);
  border: 1px solid var(--border);
  color: var(--fg);
}
.hidden { display: none; }
.gif-frame-info {
  font-size: 10px;
  color: var(--fg-dim);
  margin-top: 8px;
  text-align: center;
}
.scope-options label {
  display: block;
  font-size: 11px;
  color: var(--fg);
  margin: 6px 0;
  cursor: pointer;
}
.scope-options input[type="radio"] {
  margin-right: 6px;
  accent-color: var(--accent);
}
.action-section {
  margin-bottom: 16px;
  padding-bottom: 16px;
  border-bottom: 1px solid var(--border);
}
.action-section:last-child {
  border-bottom: none;
  margin-bottom: 0;
  padding-bottom: 0;
}
.footer { margin-top: 24px; font-size: 11px; color: var(--fg-dim); }
.footer span { color: var(--accent); }
#fileInput { display: none; }
@media (max-width: 1400px) {
  .main-layout { grid-template-columns: 1fr; }
}
</style>
</head>
<body>
<div class="container">
  <h1>PROTECTED HEX EDITOR</h1>
  <p class="subtitle">Header-safe hex editing with virtual scrolling and GIF frame support</p>
  
  <div class="controls">
    <input type="file" id="fileInput" accept=".jpg,.jpeg,.png,.gif,.webp,.bmp,.tif,.tiff">
    <button class="btn" onclick="document.getElementById('fileInput').click()">OPEN</button>
    <button class="btn" id="saveBtn" disabled onclick="saveFile()">SAVE</button>
    <button class="btn btn-secondary" id="undoBtn" disabled onclick="undo()">UNDO <span id="undoCount"></span></button>
    <button class="btn btn-secondary" id="resetBtn" disabled onclick="resetFile()">RESET</button>
    <div class="file-info" id="fileInfo"></div>
  </div>
  
  <!-- GIF Frame Navigation -->
  <div id="gifNavigation" class="hidden">
    <div class="panel">
      <div class="panel-title">GIF FRAME NAVIGATION</div>
      <div class="ctrl-row">
        <button class="btn btn-small" onclick="changeGifFrame(-1)">← PREV</button>
        <input type="number" id="gifFrameInput" value="0" min="0" style="width:60px;text-align:center" onchange="setGifFrame(parseInt(this.value))">
        <button class="btn btn-small" onclick="changeGifFrame(1)">NEXT →</button>
      </div>
      <div class="gif-frame-info">
        Frame <span id="currentGifFrame">0</span> / <span id="totalGifFrames">0</span>
      </div>
    </div>
  </div>
  
  <div class="main-layout">
    <!-- Column 1: File Structure -->
    <div class="panel structure-panel">
      <div class="panel-title">FILE STRUCTURE</div>
      <div id="structureList"><p style="color:var(--fg-dim);font-size:12px;margin-top:16px">No file loaded</p></div>
    </div>
    
    <!-- Column 2: Hex Editor -->
    <div>
      <div class="panel hex-panel">
        <div class="panel-title">HEX VIEW</div>
        <div class="legend">
          <span class="legend-protected">■ PROTECTED</span>
          <span class="legend-editable">■ EDITABLE</span>
        </div>
        <div class="hex-wrapper">
          <div class="hex-container" id="hexView"></div>
          <div class="hex-scrollbar" id="hexScrollbar">
            <div class="hex-scrollbar-thumb" id="hexScrollbarThumb"></div>
          </div>
        </div>
        <div class="hex-status" id="hexStatus"></div>
      </div>
    </div>
    
    <!-- Column 3: Preview and Tools -->
    <div>
      <!-- Preview -->
      <div class="panel">
        <div class="panel-title">PREVIEW</div>
        <div class="preview-controls">
          <span style="font-size:10px;color:var(--fg-dim)">ZOOM</span>
          <button class="zoom-btn active" onclick="setZoom(1)">1×</button>
          <button class="zoom-btn" onclick="setZoom(2)">2×</button>
          <button class="zoom-btn" onclick="setZoom(4)">4×</button>
        </div>
        <div class="preview-box" id="previewBox">
          <span style="color:var(--fg-dim);font-size:12px">No image</span>
        </div>
      </div>
      
      <!-- Selection Panel -->
      <div class="panel">
        <div class="panel-title">1. SELECTION</div>
        <div class="field-label">Find & Select</div>
        <div style="display:grid;grid-template-columns:1fr auto;gap:6px">
          <input type="text" id="findInput" placeholder="FF D8">
          <button class="btn btn-small" onclick="findAndSelect()">FIND</button>
        </div>
        <div class="field-label">Select Bytes</div>
        <div class="ctrl-row">
          <button class="btn btn-small btn-secondary" onclick="selectColumn()">↕ COL</button>
          <button class="btn btn-small btn-secondary" onclick="selectRow()">↔ ROW</button>
        </div>
        <div class="ctrl-row" style="margin-top:4px">
          <button class="btn btn-small btn-secondary" onclick="expandSelection()">+</button>
          <button class="btn btn-small btn-secondary" onclick="shrinkSelection()">−</button>
          <button class="btn btn-small btn-secondary" onclick="clearSelection()">✕</button>
        </div>
        <div id="selectionInfo" style="font-size:10px;color:var(--fg-dim);margin-top:8px">No selection</div>
      </div>
      
      <!-- Scope Panel -->
      <div id="scopePanel" class="panel hidden">
        <div class="panel-title">2. SCOPE</div>
        <div class="scope-options">
          <label><input type="radio" name="frameScope" value="current" checked>Current Frame</label>
          <label><input type="radio" name="frameScope" value="all">All Frames</label>
        </div>
      </div>
      
      <!-- Action Panel -->
      <div class="panel">
        <div class="panel-title" id="actionPanelTitle">2. ACTION</div>
        
        <div class="action-section">
          <div class="field-label">Basic Operations</div>
          <div class="ctrl-row">
            <button class="btn btn-small btn-action" onclick="deleteSelection()">DEL</button>
            <button class="btn btn-small btn-action" onclick="invertSelection()">INV</button>
            <button class="btn btn-small btn-action" onclick="randomizeSelection()">RND</button>
          </div>
        </div>
        
        <div class="action-section">
          <div class="field-label">Set Value</div>
          <div style="display:grid;grid-template-columns:1fr auto;gap:6px">
            <input type="text" id="setValueInput" placeholder="FF" maxlength="2">
            <button class="btn btn-small btn-action" onclick="setValueAction()">SET</button>
          </div>
        </div>
        
        <div class="action-section">
          <div class="field-label">Gradient</div>
          <div style="display:grid;grid-template-columns:auto 1fr auto;gap:6px;margin-bottom:6px">
            <input type="text" id="gradientStart" placeholder="00" maxlength="2" style="width:45px">
            <span style="text-align:center;align-self:center;color:var(--fg-dim)">→</span>
            <input type="text" id="gradientEnd" placeholder="FF" maxlength="2" style="width:45px">
          </div>
          <div class="ctrl-row">
            <button class="btn btn-small btn-action" onclick="applyGradient('absolute')">ABS</button>
            <button class="btn btn-small btn-action" onclick="applyGradient('relative')">REL</button>
          </div>
        </div>
        
        <div class="action-section">
          <div class="field-label">Pattern</div>
          <div style="display:grid;grid-template-columns:1fr auto;gap:6px">
            <input type="text" id="patternInput" placeholder="FF 00 FF">
            <button class="btn btn-small btn-action" onclick="applyPattern()">GO</button>
          </div>
        </div>
        
        <div class="action-section">
          <div class="field-label">Shift Bytes</div>
          <div style="display:grid;grid-template-columns:1fr auto;gap:6px">
            <input type="number" id="shiftAmount" value="1" style="width:100%">
            <button class="btn btn-small btn-action" onclick="shiftBytes()">↔</button>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <div class="footer">
    <span>FORMATS</span> JPEG · PNG · GIF · WebP · BMP · TIFF &nbsp;|&nbsp;
    <span>NEW</span> Virtual scrolling · Multi-select · GIF frames &nbsp;|&nbsp;
    <span>SELECT</span> Shift+Click · Column/Row tools
  </div>
</div>

<script>
const BYTES_PER_ROW = 16;
const VISIBLE_ROWS = 28;
const ROW_HEIGHT = 17;
const MAX_UNDO = 10;

let data = null, originalData = null, regions = [], regionMap = {}, format = null, filename = '';
let undoStack = [];
let selectedBytes = new Set();
let currentZoom = 1;
let scrollOffset = 0;

// GIF-specific state
let gifFrames = [];
let currentGifFrame = 0;
let isAnimatedFormat = false;

// Parsers
function parseJPEG(d) {
  const r = []; let pos = 0, scanStart = null;
  if (d.length < 2 || d[0] !== 0xFF || d[1] !== 0xD8) return null;
  const getU16 = p => (d[p] << 8) | d[p + 1];
  while (pos < d.length - 1) {
    if (d[pos] !== 0xFF) { pos++; continue; }
    const m = d[pos + 1];
    if (m === 0xD8) { r.push({start:pos,end:pos+2,type:'header',desc:'SOI'}); pos+=2; }
    else if (m === 0xD9) { if(scanStart!==null) r.push({start:scanStart,end:pos,type:'content',desc:'Scan Data (EDITABLE)'}); r.push({start:pos,end:pos+2,type:'header',desc:'EOI'}); break; }
    else if (m >= 0xD0 && m <= 0xD7) { pos += 2; }
    else if (m === 0xDA) { if(pos+4>d.length)break; const len=getU16(pos+2); r.push({start:pos,end:pos+2+len,type:'header',desc:'SOS'}); scanStart=pos+2+len; pos=scanStart; }
    else if (m !== 0x00 && m !== 0xFF) { if(pos+4>d.length)break; const len=getU16(pos+2); const names={0xE0:'APP0',0xE1:'APP1/EXIF',0xDB:'DQT',0xC4:'DHT',0xC0:'SOF0',0xC2:'SOF2',0xFE:'COM'}; r.push({start:pos,end:pos+2+len,type:'header',desc:names[m]||`0x${m.toString(16).toUpperCase()}`}); pos+=2+len; }
    else { pos++; }
  }
  return r.length ? r : null;
}

function parsePNG(d) {
  const r = [], sig = [0x89,0x50,0x4E,0x47,0x0D,0x0A,0x1A,0x0A];
  if (d.length < 8 || !sig.every((b,i) => d[i] === b)) return null;
  r.push({start:0,end:8,type:'header',desc:'PNG Signature'});
  let pos = 8;
  const getU32 = p => (d[p]<<24)|(d[p+1]<<16)|(d[p+2]<<8)|d[p+3];
  while (pos < d.length - 8) {
    const len = getU32(pos), type = String.fromCharCode(...d.slice(pos+4,pos+8)), end = pos+12+len;
    if (end > d.length) break;
    if (type === 'IDAT') { r.push({start:pos,end:pos+8,type:'header',desc:'IDAT Header'}); r.push({start:pos+8,end:pos+8+len,type:'content',desc:'IDAT Data (EDITABLE)'}); r.push({start:pos+8+len,end:end,type:'header',desc:'IDAT CRC'}); }
    else { r.push({start:pos,end:end,type:'header',desc:`${type} Chunk`}); }
    pos = end; if (type === 'IEND') break;
  }
  return r;
}

function parseGIF(d) {
  const r = [];
  const frames = [];
  if (d.length < 6 || String.fromCharCode(...d.slice(0,3)) !== 'GIF') return null;
  r.push({start:0,end:6,type:'header',desc:'GIF Header'});
  if (d.length < 13) return {regions: r, frames: []};
  r.push({start:6,end:13,type:'header',desc:'Screen Descriptor'});
  const packed = d[10], hasGCT = packed & 0x80, gctSize = hasGCT ? 3 * Math.pow(2,(packed&0x07)+1) : 0;
  let pos = 13;
  if (hasGCT) { r.push({start:pos,end:pos+gctSize,type:'header',desc:'Global Color Table'}); pos += gctSize; }
  let frameIndex = 0;
  while (pos < d.length) {
    if (d[pos] === 0x3B) { r.push({start:pos,end:pos+1,type:'header',desc:'Trailer'}); break; }
    else if (d[pos] === 0x21) { const extStart=pos; pos+=2; while(pos<d.length&&d[pos]!==0)pos+=d[pos]+1; pos++; r.push({start:extStart,end:pos,type:'header',desc:'Extension'}); }
    else if (d[pos] === 0x2C) { 
      if(pos+10>d.length)break; 
      const p=d[pos+9],hasLCT=p&0x80,lctSize=hasLCT?3*Math.pow(2,(p&0x07)+1):0; 
      const imageDescStart = pos;
      r.push({start:pos,end:pos+10,type:'header',desc:`Image Descriptor ${frameIndex}`}); 
      pos+=10; 
      if(hasLCT){r.push({start:pos,end:pos+lctSize,type:'header',desc:'Local Color Table'});pos+=lctSize;} 
      r.push({start:pos,end:pos+1,type:'header',desc:'LZW Min Code'}); 
      pos++; 
      const dataStart=pos; 
      while(pos<d.length&&d[pos]!==0)pos+=d[pos]+1; 
      if(pos>dataStart) {
        r.push({start:dataStart,end:pos,type:'content',desc:`Frame ${frameIndex} Data (EDITABLE)`});
        frames.push({start:dataStart, end:pos, frameIndex: frameIndex, desc: `Frame ${frameIndex}`});
      }
      pos++;
      frameIndex++;
    }
    else { pos++; }
  }
  return {regions: r, frames: frames};
}

function parseWebP(d) {
  const r = [];
  if (d.length<12 || String.fromCharCode(...d.slice(0,4))!=='RIFF' || String.fromCharCode(...d.slice(8,12))!=='WEBP') return null;
  r.push({start:0,end:12,type:'header',desc:'RIFF/WebP Header'});
  let pos = 12;
  const getU32LE = p => d[p]|(d[p+1]<<8)|(d[p+2]<<16)|(d[p+3]<<24);
  while (pos < d.length - 8) {
    const id = String.fromCharCode(...d.slice(pos,pos+4)), size = getU32LE(pos+4), end = pos+8+size+(size%2);
    if (end > d.length) break;
    if (id==='VP8 '||id==='VP8L') { const hdr=id==='VP8 '?10:5; r.push({start:pos,end:pos+8+Math.min(hdr,size),type:'header',desc:`${id.trim()} Header`}); if(size>hdr)r.push({start:pos+8+hdr,end:pos+8+size,type:'content',desc:`${id.trim()} Data (EDITABLE)`}); }
    else { r.push({start:pos,end:end,type:'header',desc:`${id.trim()} Chunk`}); }
    pos = end;
  }
  return r.length > 1 ? r : null;
}

function parseBMP(d) {
  if (d.length<54||d[0]!==0x42||d[1]!==0x4D) return null;
  const getU32LE = p => d[p]|(d[p+1]<<8)|(d[p+2]<<16)|(d[p+3]<<24);
  const dataOff = getU32LE(10), hdrSize = getU32LE(14);
  const r = [{start:0,end:14,type:'header',desc:'BMP File Header'},{start:14,end:14+hdrSize,type:'header',desc:'DIB Header'}];
  if (dataOff > 14+hdrSize) r.push({start:14+hdrSize,end:dataOff,type:'header',desc:'Color Table'});
  r.push({start:dataOff,end:d.length,type:'content',desc:'Pixel Data (EDITABLE)'});
  return r;
}

function parseTIFF(d) {
  if (d.length<8) return null;
  const le = d[0]===0x49&&d[1]===0x49, be = d[0]===0x4D&&d[1]===0x4D;
  if (!le && !be) return null;
  const getU16 = le ? p=>d[p]|(d[p+1]<<8) : p=>(d[p]<<8)|d[p+1];
  const getU32 = le ? p=>d[p]|(d[p+1]<<8)|(d[p+2]<<16)|(d[p+3]<<24) : p=>(d[p]<<24)|(d[p+1]<<16)|(d[p+2]<<8)|d[p+3];
  if (getU16(2) !== 42) return null;
  const r = [{start:0,end:8,type:'header',desc:'TIFF Header'}];
  let ifdOff = getU32(4); const strips = [];
  while (ifdOff > 0 && ifdOff < d.length-2) {
    const num = getU16(ifdOff), ifdEnd = ifdOff+2+num*12+4;
    if (ifdEnd > d.length) break;
    r.push({start:ifdOff,end:ifdEnd,type:'header',desc:'IFD'});
    for (let i=0;i<num;i++) { const eOff=ifdOff+2+i*12,tag=getU16(eOff),typ=getU16(eOff+2),cnt=getU32(eOff+4),sz={1:1,2:1,3:2,4:4,5:8}[typ]||1,tot=cnt*sz; let vals=[]; if(tot<=4){for(let j=0;j<cnt;j++)vals.push(sz===2?getU16(eOff+8+j*2):getU32(eOff+8+j*4));}else{const vOff=getU32(eOff+8);for(let j=0;j<cnt&&vOff+j*sz<d.length;j++)vals.push(sz===2?getU16(vOff+j*2):getU32(vOff+j*4));} if(tag===273)strips.push({offsets:vals});else if(tag===279&&strips.length)strips[strips.length-1].sizes=vals; }
    ifdOff = getU32(ifdOff+2+num*12);
  }
  strips.forEach(s => { if(s.offsets&&s.sizes) s.offsets.forEach((off,i)=>{ if(off+(s.sizes[i]||0)<=d.length) r.push({start:off,end:off+s.sizes[i],type:'content',desc:`Strip ${i+1} (EDITABLE)`}); }); });
  r.sort((a,b)=>a.start-b.start);
  return r.length > 1 ? r : null;
}

function parseFormat(d, fname) {
  const ext = fname.toLowerCase().split('.').pop();
  const parsers = [
    {exts:['jpg','jpeg'],fn:parseJPEG,name:'JPEG'},
    {exts:['png'],fn:parsePNG,name:'PNG'},
    {exts:['gif'],fn:parseGIF,name:'GIF',special:true},
    {exts:['webp'],fn:parseWebP,name:'WebP'},
    {exts:['bmp'],fn:parseBMP,name:'BMP'},
    {exts:['tif','tiff','dng'],fn:parseTIFF,name:'TIFF'}
  ];
  
  for (const p of parsers) { 
    if(p.exts.includes(ext)){
      const r = p.fn(d);
      if(r) {
        if(p.special && r.regions) {
          return {regions: r.regions, format: p.name, frames: r.frames || []};
        }
        return {regions:r,format:p.name,frames:[]};
      }
    } 
  }
  
  for (const p of parsers) { 
    const r = p.fn(d); 
    if(r) {
      if(p.special && r.regions) {
        return {regions: r.regions, format: p.name, frames: r.frames || []};
      }
      return {regions:r,format:p.name,frames:[]};
    }
  }
  return {regions:null,format:null,frames:[]};
}

function isEditable(pos) { return regionMap[pos] === 'content'; }

function pushUndo() {
  if (!data) return;
  undoStack.push(new Uint8Array(data));
  if (undoStack.length > MAX_UNDO) undoStack.shift();
  updateUndoButton();
}

function undo() {
  if (undoStack.length === 0) return;
  data = undoStack.pop();
  updateUndoButton();
  renderHex();
  updatePreview();
}

function updateUndoButton() {
  const btn = document.getElementById('undoBtn');
  const count = document.getElementById('undoCount');
  btn.disabled = !data || undoStack.length === 0;
  count.textContent = undoStack.length > 0 ? `(${undoStack.length})` : '';
}

function renderHex() {
  const container = document.getElementById('hexView');
  container.innerHTML = '';
  if (!data) {
    updateHexScrollbar();
    return;
  }
  
  const totalRows = Math.ceil(data.length / BYTES_PER_ROW);
  const startRow = scrollOffset;
  const endRow = Math.min(startRow + VISIBLE_ROWS, totalRows);
  const fragment = document.createDocumentFragment();
  
  for (let row = startRow; row < endRow; row++) {
    const rowDiv = document.createElement('div');
    rowDiv.className = 'hex-row';
    
    const offset = row * BYTES_PER_ROW;
    const offsetSpan = document.createElement('span');
    offsetSpan.className = 'hex-offset';
    offsetSpan.textContent = offset.toString(16).toUpperCase().padStart(8, '0');
    rowDiv.appendChild(offsetSpan);
    
    const bytesDiv = document.createElement('div');
    bytesDiv.className = 'hex-bytes';
    
    let ascii = '';
    for (let i = 0; i < BYTES_PER_ROW; i++) {
      const pos = offset + i;
      if (pos >= data.length) break;
      
      const byte = data[pos];
      const editable = isEditable(pos);
      
      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'hex-byte' + (editable ? ' hex-byte-editable' : ' hex-byte-protected');
      input.value = byte.toString(16).toUpperCase().padStart(2, '0');
      input.maxLength = 2;
      input.dataset.pos = pos;
      
      if (selectedBytes.has(pos)) {
        input.classList.add('selected');
      }
      
      if (!editable) {
        input.disabled = true;
      }
      
      input.addEventListener('click', (e) => handleByteClick(e, pos));
      input.addEventListener('change', (e) => handleByteChange(e, pos));
      input.addEventListener('keydown', (e) => handleByteKeydown(e, pos));
      input.addEventListener('focus', () => updateStatus(pos));
      
      bytesDiv.appendChild(input);
      ascii += byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : '·';
    }
    
    rowDiv.appendChild(bytesDiv);
    
    const asciiSpan = document.createElement('span');
    asciiSpan.className = 'hex-ascii';
    asciiSpan.textContent = ascii;
    rowDiv.appendChild(asciiSpan);
    
    fragment.appendChild(rowDiv);
  }
  
  container.appendChild(fragment);
  updateHexScrollbar();
  updateStatus();
}

function updateHexScrollbar() {
  const scrollbar = document.getElementById('hexScrollbar');
  const thumb = document.getElementById('hexScrollbarThumb');
  
  if (!scrollbar || !thumb) return;
  
  if (!data) {
    thumb.style.display = 'none';
    return;
  }
  
  const totalRows = Math.ceil(data.length / BYTES_PER_ROW);
  const trackHeight = 520;
  
  if (totalRows <= VISIBLE_ROWS) {
    thumb.style.display = 'none';
    return;
  }
  
  thumb.style.display = 'block';
  const thumbHeight = Math.max(20, (VISIBLE_ROWS / totalRows) * trackHeight);
  const maxScroll = totalRows - VISIBLE_ROWS;
  const thumbTop = (scrollOffset / maxScroll) * (trackHeight - thumbHeight);
  
  thumb.style.height = thumbHeight + 'px';
  thumb.style.top = thumbTop + 'px';
}

function handleByteClick(e, pos) {
  if (e.shiftKey) {
    if (selectedBytes.size === 0) {
      selectedBytes.add(pos);
    } else {
      const first = Math.min(...selectedBytes);
      const last = Math.max(...selectedBytes);
      const start = Math.min(first, pos);
      const end = Math.max(last, pos);
      for (let i = start; i <= end; i++) {
        selectedBytes.add(i);
      }
    }
    updateSelectionVisuals();
  } else if (e.ctrlKey || e.metaKey) {
    if (selectedBytes.has(pos)) {
      selectedBytes.delete(pos);
    } else {
      selectedBytes.add(pos);
    }
    updateSelectionVisuals();
  } else {
    selectedBytes.clear();
    selectedBytes.add(pos);
    updateSelectionVisuals();
  }
}

function updateSelectionVisuals() {
  document.querySelectorAll('.hex-byte').forEach(input => {
    const pos = parseInt(input.dataset.pos);
    if (selectedBytes.has(pos)) {
      input.classList.add('selected');
    } else {
      input.classList.remove('selected');
    }
  });
  updateStatus();
}

function handleByteChange(e, pos) {
  if (!isEditable(pos)) return;
  
  const value = e.target.value.trim();
  if (!/^[0-9A-Fa-f]{1,2}$/.test(value)) {
    e.target.value = data[pos].toString(16).toUpperCase().padStart(2, '0');
    return;
  }
  
  pushUndo();
  data[pos] = parseInt(value, 16);
  updatePreview();
}

function handleByteKeydown(e, pos) {
  if (e.key === 'ArrowRight' || e.key === 'Tab') {
    e.preventDefault();
    const next = pos + 1;
    if (next < data.length) {
      const nextInput = document.querySelector(`input[data-pos="${next}"]`);
      if (nextInput) {
        nextInput.focus();
      } else {
        scrollToPosition(next);
      }
    }
  } else if (e.key === 'ArrowLeft') {
    e.preventDefault();
    const prev = pos - 1;
    if (prev >= 0) {
      const prevInput = document.querySelector(`input[data-pos="${prev}"]`);
      if (prevInput) {
        prevInput.focus();
      } else {
        scrollToPosition(prev);
      }
    }
  } else if (e.key === 'ArrowUp') {
    e.preventDefault();
    const up = pos - BYTES_PER_ROW;
    if (up >= 0) {
      scrollToPosition(up);
    }
  } else if (e.key === 'ArrowDown') {
    e.preventDefault();
    const down = pos + BYTES_PER_ROW;
    if (down < data.length) {
      scrollToPosition(down);
    }
  }
}

function scrollToPosition(pos) {
  const row = Math.floor(pos / BYTES_PER_ROW);
  const totalRows = Math.ceil(data.length / BYTES_PER_ROW);
  
  if (row < scrollOffset || row >= scrollOffset + VISIBLE_ROWS) {
    scrollOffset = Math.max(0, Math.min(row - 5, totalRows - VISIBLE_ROWS));
    renderHex();
    setTimeout(() => {
      const input = document.querySelector(`input[data-pos="${pos}"]`);
      if (input) input.focus();
    }, 10);
  }
}

function updateStatus(pos = null) {
  const el = document.getElementById('hexStatus');
  if (!data) { el.innerHTML = ''; return; }
  
  const totalRows = Math.ceil(data.length / BYTES_PER_ROW);
  const currentRow = scrollOffset + 1;
  const endRow = Math.min(scrollOffset + VISIBLE_ROWS, totalRows);
  
  let statusHTML = `Rows ${currentRow}-${endRow} of ${totalRows} · ${data.length.toLocaleString()} bytes`;
  
  if (pos !== null && pos !== undefined) {
    const editable = isEditable(pos);
    statusHTML += ` · Pos: <span class="pos">${pos.toString(16).toUpperCase().padStart(8,'0')}</span> <span class="${editable?'status-editable':'status-locked'}">${editable?'EDIT':'LOCK'}</span>`;
  }
  
  if (selectedBytes.size > 0) {
    statusHTML += ` · <span style="color:var(--accent)">${selectedBytes.size} selected</span>`;
  }
  
  el.innerHTML = statusHTML;
  updateSelectionInfo();
}

function updateSelectionInfo() {
  const el = document.getElementById('selectionInfo');
  if (!data || selectedBytes.size === 0) {
    el.textContent = 'No selection';
    return;
  }
  
  const bytes = Array.from(selectedBytes).sort((a,b) => a-b);
  let hexPreview = '';
  for (let i = 0; i < Math.min(bytes.length, 6); i++) {
    hexPreview += data[bytes[i]].toString(16).toUpperCase().padStart(2, '0') + ' ';
  }
  if (bytes.length > 6) hexPreview += '...';
  
  el.innerHTML = `<span style="color:var(--accent)">${bytes.length} bytes</span><br><span style="color:var(--fg-dim)">${hexPreview}</span>`;
}

function clearSelection() {
  selectedBytes.clear();
  renderHex();
}

function selectColumn() {
  if (selectedBytes.size === 0) {
    alert('Select at least one byte first');
    return;
  }
  
  const cols = new Set();
  selectedBytes.forEach(pos => {
    cols.add(pos % BYTES_PER_ROW);
  });
  
  selectedBytes.clear();
  const totalRows = Math.ceil(data.length / BYTES_PER_ROW);
  for (let row = 0; row < totalRows; row++) {
    cols.forEach(col => {
      const pos = row * BYTES_PER_ROW + col;
      if (pos < data.length && isEditable(pos)) {
        selectedBytes.add(pos);
      }
    });
  }
  renderHex();
}

function selectRow() {
  if (selectedBytes.size === 0) {
    alert('Select at least one byte first');
    return;
  }
  
  const rows = new Set();
  selectedBytes.forEach(pos => {
    rows.add(Math.floor(pos / BYTES_PER_ROW));
  });
  
  selectedBytes.clear();
  rows.forEach(row => {
    const start = row * BYTES_PER_ROW;
    const end = Math.min(start + BYTES_PER_ROW, data.length);
    for (let pos = start; pos < end; pos++) {
      if (isEditable(pos)) {
        selectedBytes.add(pos);
      }
    }
  });
  renderHex();
}

function expandSelection() {
  if (selectedBytes.size === 0) {
    alert('Select at least one byte first');
    return;
  }
  
  const toAdd = new Set();
  
  selectedBytes.forEach(pos => {
    if (pos > 0 && pos % BYTES_PER_ROW !== 0) {
      if (isEditable(pos - 1)) toAdd.add(pos - 1);
    }
    if ((pos + 1) % BYTES_PER_ROW !== 0 && pos + 1 < data.length) {
      if (isEditable(pos + 1)) toAdd.add(pos + 1);
    }
    if (pos >= BYTES_PER_ROW) {
      if (isEditable(pos - BYTES_PER_ROW)) toAdd.add(pos - BYTES_PER_ROW);
    }
    if (pos + BYTES_PER_ROW < data.length) {
      if (isEditable(pos + BYTES_PER_ROW)) toAdd.add(pos + BYTES_PER_ROW);
    }
  });
  
  toAdd.forEach(pos => selectedBytes.add(pos));
  renderHex();
}

function shrinkSelection() {
  if (selectedBytes.size === 0) return;
  
  const bytes = Array.from(selectedBytes).sort((a,b) => a-b);
  const min = bytes[0];
  const max = bytes[bytes.length - 1];
  
  selectedBytes.delete(min);
  selectedBytes.delete(max);
  
  renderHex();
}

function findAndSelect() {
  const query = document.getElementById('findInput').value.trim();
  if (!query || !data) return;
  
  const searchBytes = [];
  const hex = query.replace(/[^0-9a-fA-F]/g, '');
  for (let i = 0; i + 1 < hex.length; i += 2) {
    searchBytes.push(parseInt(hex.substr(i, 2), 16));
  }
  
  if (searchBytes.length === 0) return;
  
  selectedBytes.clear();
  for (let i = 0; i <= data.length - searchBytes.length; i++) {
    let match = true;
    for (let j = 0; j < searchBytes.length; j++) {
      if (data[i + j] !== searchBytes[j]) {
        match = false;
        break;
      }
    }
    if (match) {
      for (let j = 0; j < searchBytes.length; j++) {
        if (isEditable(i + j)) {
          selectedBytes.add(i + j);
        }
      }
    }
  }
  
  renderHex();
  if (selectedBytes.size > 0) {
    const occurrences = selectedBytes.size / searchBytes.length;
    alert(`Found ${occurrences} occurrence${occurrences > 1 ? 's' : ''}`);
  } else {
    alert('No matches found');
  }
}

function getSelectedEditableBytes() {
  return Array.from(selectedBytes).filter(pos => isEditable(pos)).sort((a,b) => a-b);
}

function deleteSelection() {
  const editable = getSelectedEditableBytes();
  if (editable.length === 0) {
    alert('No editable bytes selected');
    return;
  }
  
  pushUndo();
  editable.forEach(pos => data[pos] = 0x00);
  renderHex();
  updatePreview();
}

function invertSelection() {
  const editable = getSelectedEditableBytes();
  if (editable.length === 0) {
    alert('No editable bytes selected');
    return;
  }
  
  pushUndo();
  editable.forEach(pos => data[pos] = 0xFF - data[pos]);
  renderHex();
  updatePreview();
}

function randomizeSelection() {
  const editable = getSelectedEditableBytes();
  if (editable.length === 0) {
    alert('No editable bytes selected');
    return;
  }
  
  pushUndo();
  editable.forEach(pos => data[pos] = Math.floor(Math.random() * 256));
  renderHex();
  updatePreview();
}

function setValueAction() {
  const value = document.getElementById('setValueInput').value.trim();
  if (!/^[0-9A-Fa-f]{1,2}$/.test(value)) {
    alert('Enter a valid hex value (00-FF)');
    return;
  }
  
  const editable = getSelectedEditableBytes();
  if (editable.length === 0) {
    alert('No editable bytes selected');
    return;
  }
  
  pushUndo();
  const byteValue = parseInt(value, 16);
  editable.forEach(pos => data[pos] = byteValue);
  renderHex();
  updatePreview();
}

function applyGradient(mode) {
  const startHex = document.getElementById('gradientStart').value.trim();
  const endHex = document.getElementById('gradientEnd').value.trim();
  
  if (!/^[0-9A-Fa-f]{1,2}$/.test(startHex) || !/^[0-9A-Fa-f]{1,2}$/.test(endHex)) {
    alert('Enter valid hex values (00-FF)');
    return;
  }
  
  const editable = getSelectedEditableBytes();
  if (editable.length === 0) {
    alert('No editable bytes selected');
    return;
  }
  
  pushUndo();
  const start = parseInt(startHex, 16);
  const end = parseInt(endHex, 16);
  
  if (mode === 'absolute') {
    editable.forEach((pos, i) => {
      const t = editable.length > 1 ? i / (editable.length - 1) : 0;
      data[pos] = Math.round(start + (end - start) * t);
    });
  } else {
    editable.forEach((pos, i) => {
      const t = editable.length > 1 ? i / (editable.length - 1) : 0;
      const offset = Math.round((end - start) * t);
      data[pos] = (data[pos] + offset) & 0xFF;
    });
  }
  
  renderHex();
  updatePreview();
}

function applyPattern() {
  const hex = document.getElementById('patternInput').value.replace(/[^0-9a-fA-F]/g, '');
  const patternBytes = [];
  for (let i = 0; i < hex.length; i += 2) {
    patternBytes.push(parseInt(hex.substr(i, 2), 16));
  }
  
  if (patternBytes.length === 0) {
    alert('Enter a valid hex pattern');
    return;
  }
  
  const editable = getSelectedEditableBytes();
  if (editable.length === 0) {
    alert('No editable bytes selected');
    return;
  }
  
  pushUndo();
  editable.forEach((pos, i) => {
    data[pos] = patternBytes[i % patternBytes.length];
  });
  renderHex();
  updatePreview();
}

function shiftBytes() {
  const amount = parseInt(document.getElementById('shiftAmount').value);
  if (isNaN(amount)) {
    alert('Enter a valid number');
    return;
  }
  
  const editable = getSelectedEditableBytes();
  if (editable.length === 0) {
    alert('No editable bytes selected');
    return;
  }
  
  pushUndo();
  editable.forEach(pos => {
    data[pos] = (data[pos] + amount) & 0xFF;
  });
  renderHex();
  updatePreview();
}

function updatePreview() {
  const box = document.getElementById('previewBox');
  if (!data) { 
    box.innerHTML = '<span style="color:var(--fg-dim);font-size:12px">No image</span>'; 
    return; 
  }
  
  const blob = new Blob([data]);
  const url = URL.createObjectURL(blob);
  const img = new Image();
  
  img.onload = () => {
    img.className = `zoom-${currentZoom}x`;
    img.id = 'previewImg';
    box.innerHTML = '';
    box.appendChild(img);
  };
  
  img.onerror = () => {
    box.innerHTML = '<div class="preview-error"><div class="icon">⚠ DECODE ERROR</div><div class="msg">(normal during databending)</div></div>';
  };
  
  img.src = url;
}

function setZoom(level) {
  currentZoom = level;
  document.querySelectorAll('.zoom-btn').forEach((btn, i) => {
    btn.classList.toggle('active', [1,2,4][i] === level);
  });
  const img = document.getElementById('previewImg');
  if (img) {
    img.className = `zoom-${level}x`;
  }
}

function updateStructure() {
  const el = document.getElementById('structureList');
  if (!regions.length) { 
    el.innerHTML = '<p style="color:var(--fg-dim);font-size:12px;margin-top:16px">No file loaded</p>'; 
    return; 
  }
  
  el.innerHTML = regions.map(r => 
    `<div class="structure-item ${r.type==='content'?'editable':''}" 
          style="border-color:var(--${r.type==='content'?'editable':'protected'})" 
          onclick="jumpTo(${r.start})">
      <div class="desc" style="color:var(--${r.type==='content'?'editable':'protected'})">${r.desc}</div>
      <div class="offset">${r.start.toString(16).toUpperCase().padStart(8,'0')} · ${(r.end-r.start).toLocaleString()}B</div>
    </div>`
  ).join('');
}

function jumpTo(pos) {
  selectedBytes.clear();
  selectedBytes.add(pos);
  scrollToPosition(pos);
}

function changeGifFrame(delta) {
  if (!isAnimatedFormat || gifFrames.length === 0) return;
  
  currentGifFrame = (currentGifFrame + delta + gifFrames.length) % gifFrames.length;
  updateGifFrameUI();
}

function setGifFrame(frameNum) {
  if (!isAnimatedFormat || gifFrames.length === 0) return;
  
  currentGifFrame = Math.max(0, Math.min(frameNum, gifFrames.length - 1));
  updateGifFrameUI();
}

function updateGifFrameUI() {
  document.getElementById('currentGifFrame').textContent = currentGifFrame;
  document.getElementById('gifFrameInput').value = currentGifFrame;
  
  if (gifFrames[currentGifFrame]) {
    jumpTo(gifFrames[currentGifFrame].start);
  }
}

function loadFile(file) {
  const reader = new FileReader();
  reader.onload = e => {
    const bytes = new Uint8Array(e.target.result);
    const result = parseFormat(bytes, file.name);
    
    if (!result.regions) { 
      alert('Unsupported format.\nSupported: JPEG, PNG, GIF, WebP, BMP, TIFF'); 
      return; 
    }
    
    data = bytes; 
    originalData = new Uint8Array(bytes); 
    regions = result.regions; 
    format = result.format; 
    filename = file.name;
    gifFrames = result.frames || [];
    isAnimatedFormat = gifFrames.length > 0;
    currentGifFrame = 0;
    scrollOffset = 0;
    
    regionMap = {};
    regions.forEach(r => { 
      for(let i=r.start;i<r.end;i++) regionMap[i]=r.type; 
    });
    
    undoStack = [];
    selectedBytes.clear();
    updateUndoButton();
    
    document.getElementById('gifNavigation').classList.toggle('hidden', !isAnimatedFormat);
    document.getElementById('scopePanel').classList.toggle('hidden', !isAnimatedFormat);
    document.getElementById('actionPanelTitle').textContent = isAnimatedFormat ? '3. ACTION' : '2. ACTION';
    
    if (isAnimatedFormat) {
      document.getElementById('totalGifFrames').textContent = gifFrames.length;
      document.getElementById('currentGifFrame').textContent = currentGifFrame;
      document.getElementById('gifFrameInput').value = currentGifFrame;
      document.getElementById('gifFrameInput').max = gifFrames.length - 1;
    }
    
    const editableCount = Object.values(regionMap).filter(t=>t==='content').length;
    const pct = ((editableCount/data.length)*100).toFixed(1);
    document.getElementById('fileInfo').innerHTML = `<span class="format">${format}</span> · ${data.length.toLocaleString()} bytes · <span class="editable">${pct}% editable</span>${isAnimatedFormat ? ` · <span style="color:var(--accent)">${gifFrames.length} frames</span>` : ''}`;
    
    document.getElementById('saveBtn').disabled = false;
    document.getElementById('resetBtn').disabled = false;
    
    updateStructure(); 
    renderHex(); 
    updatePreview();
  };
  reader.readAsArrayBuffer(file);
}

function saveFile() {
  if (!data) return;
  const blob = new Blob([data]);
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; 
  a.download = `glitched_${filename}`; 
  a.click();
  URL.revokeObjectURL(url);
}

function resetFile() {
  if (!originalData) return;
  data = new Uint8Array(originalData);
  undoStack = [];
  selectedBytes.clear();
  scrollOffset = 0;
  updateUndoButton();
  renderHex(); 
  updatePreview();
}

document.getElementById('fileInput').addEventListener('change', e => { 
  if(e.target.files[0]) loadFile(e.target.files[0]); 
});

const hexViewElement = document.getElementById('hexView');
if (hexViewElement) {
  hexViewElement.addEventListener('wheel', e => {
    if (!data) return;
    e.preventDefault();
    const delta = e.deltaY > 0 ? 3 : -3;
    const totalRows = Math.ceil(data.length / BYTES_PER_ROW);
    const maxScroll = Math.max(0, totalRows - VISIBLE_ROWS);
    scrollOffset = Math.max(0, Math.min(maxScroll, scrollOffset + delta));
    renderHex();
  }, {passive: false});
}

let isDraggingScrollbar = false;
const hexScrollbar = document.getElementById('hexScrollbar');
const hexScrollbarThumb = document.getElementById('hexScrollbarThumb');

if (hexScrollbar && hexScrollbarThumb) {
  hexScrollbar.addEventListener('mousedown', e => {
    if (!data) return;
    
    if (e.target === hexScrollbarThumb) {
      isDraggingScrollbar = true;
      hexScrollbarThumb.classList.add('dragging');
      return;
    }
    
    const rect = hexScrollbar.getBoundingClientRect();
    const clickY = e.clientY - rect.top;
    const totalRows = Math.ceil(data.length / BYTES_PER_ROW);
    const maxScroll = totalRows - VISIBLE_ROWS;
    const trackHeight = 520;
    const ratio = clickY / trackHeight;
    scrollOffset = Math.max(0, Math.min(maxScroll, Math.floor(ratio * totalRows)));
    renderHex();
  });

  document.addEventListener('mousemove', e => {
    if (!isDraggingScrollbar || !data) return;
    const rect = hexScrollbar.getBoundingClientRect();
    const y = e.clientY - rect.top;
    const totalRows = Math.ceil(data.length / BYTES_PER_ROW);
    const maxScroll = totalRows - VISIBLE_ROWS;
    const trackHeight = 520;
    const ratio = Math.max(0, Math.min(1, y / trackHeight));
    scrollOffset = Math.floor(ratio * maxScroll);
    renderHex();
  });

  document.addEventListener('mouseup', () => {
    isDraggingScrollbar = false;
    hexScrollbarThumb.classList.remove('dragging');
  });
}

document.addEventListener('keydown', e => {
  if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
    e.preventDefault();
    undo();
  }
});

updateUndoButton();
renderHex();
</script>
</body>
</html>
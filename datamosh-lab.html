<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DATAMOSH LAB | Frame Analysis & Effect Simulation</title>
  <meta name="author" content="Ernesto Peña">
  <meta name="description" content="Comprehensive tool for analysing video frame structure and simulating datamosh effects using motion vector estimation.">
  <meta name="citation_author" content="Peña, Ernesto">
  <meta name="citation_title" content="Datamosh Lab: A Glitch Pedagogy Tool">
  <meta name="citation_date" content="2025">
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-8XQLL5N022"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-8XQLL5N022');
  </script>
  <style>
    /* === BASE RESET === */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    /* === TYPOGRAPHY & COLORS === */
    /* Dark theme (default) */
    :root {
      --font: 'Roboto Mono', monospace;
      --bg: #0a0a0a;
      --text: #e0e0e0;
      --accent: #FF00FF;
      --accent-secondary: #00bcd4;
      --accent-tertiary: #8bc34a;
      --muted: #666;
      --border: #222;
      --panel-bg: #111;
      --hover-bg: #1a1a1a;
      --hover-text: #fff;
    }
    
    /* Light theme */
    [data-theme="light"] {
      --bg: #ffffff;
      --text: #000000;
      --accent: #FF00FF;
      --accent-secondary: #00bcd4;
      --accent-tertiary: #8bc34a;
      --muted: #666666;
      --border: #e0e0e0;
      --panel-bg: #f5f5f5;
      --hover-bg: #e8e8e8;
      --hover-text: #000;
    }
    
    body {
      font-family: 'Roboto Mono', monospace;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      padding: clamp(1rem, 1rem + ((1vw - 0.48rem) * 0.288), 1.125rem);
      line-height: 1.6;
      font-size: clamp(0.875rem, 0.875rem + ((1vw - 0.48rem) * 0.288), 1rem);
    }
    
    /* === FULL WIDTH LAYOUT CLASS === */
    .full-width-content {
      max-width: 100%;
      width: 100%;
    }
    
    /* === HEADER === */
    header {
      margin-bottom: clamp(1rem, 1rem + ((1vw - 0.48rem) * 0.288), 1.125rem);
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      flex-wrap: wrap;
      gap: 12px;
    }
    
    .header-content {
      flex: 1;
      min-width: 200px;
    }
    
    .theme-toggle {
      padding: 6px 12px;
      background: var(--panel-bg);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      cursor: pointer;
      font-family: inherit;
      font-size: clamp(0.625rem, 0.625rem + ((1vw - 0.48rem) * 0.072), 0.6563rem);
      transition: all 0.15s;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .theme-toggle:hover {
      border-color: var(--accent);
      background: var(--hover-bg);
    }
    
    .theme-toggle:focus {
      outline: 2px dashed var(--accent);
      outline-offset: 2px;
    }
    
    h1 {
      color: var(--accent);
      font-size: clamp(1.75rem, 1.75rem + ((1vw - 0.48rem) * 0.288), 1.875rem);
      margin-bottom: 2px;
      font-weight: 400;
      line-height: 1.2;
    }
    
    .subtitle {
      color: var(--muted);
      font-size: clamp(0.875rem, 0.875rem + ((1vw - 0.48rem) * 0.144), 0.9375rem);
      line-height: 1.5;
    }
    
    /* === UPLOAD AREA === */
    .upload-area {
      text-align: center;
      padding: clamp(1.5rem, 1.5rem + ((1vw - 0.48rem) * 1.442), 2rem);
      border: 2px dashed #333;
      border-radius: 6px;
      margin-bottom: clamp(1rem, 1rem + ((1vw - 0.48rem) * 0.288), 1.125rem);
      transition: all 0.3s;
    }
    
    .upload-area:hover,
    .upload-area.dragover {
      border-color: var(--accent);
      background: rgba(255, 0, 255, 0.03);
    }
    
    .upload-btn {
      display: inline-block;
      padding: 11px 22px;
      background: var(--hover-bg);
      border: 2px solid var(--accent);
      border-radius: 4px;
      color: var(--accent);
      cursor: pointer;
      font-family: inherit;
      font-size: clamp(0.75rem, 0.75rem + ((1vw - 0.48rem) * 0.144), 0.8125rem);
      transition: all 0.15s;
      text-decoration: none;
    }
    
    .upload-btn:hover {
      background: var(--accent);
      color: var(--bg);
    }
    
    .upload-btn:focus {
      outline: 2px dashed var(--accent);
      outline-offset: 2px;
    }
    
    .upload-btn:active {
      transform: scale(0.98);
    }
    
    .upload-btn input { display: none; }
    
    .status-msg {
      margin-top: 12px;
      padding: 10px;
      background: var(--hover-bg);
      border-radius: 4px;
      font-size: clamp(0.75rem, 0.75rem + ((1vw - 0.48rem) * 0.072), 0.7813rem);
      display: inline-block;
    }
    
    .progress-bar {
      height: 4px;
      background: #333;
      border-radius: 2px;
      margin-top: 8px;
      overflow: hidden;
      width: 200px;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--accent-secondary));
      transition: width 0.2s;
    }
    
    /* === MAIN GRID === */
    .main-grid {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 1.5rem;
    }
    
    @media (max-width: 1150px) {
      .main-grid { grid-template-columns: 1fr 1fr; }
    }
    
    @media (max-width: 780px) {
      .main-grid { grid-template-columns: 1fr; }
    }
    
    /* === PANEL === */
    .panel {
      background: var(--panel-bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 1.5rem;
    }
    
    .panel-title {
      color: var(--accent);
      font-size: clamp(0.75rem, 0.75rem + ((1vw - 0.48rem) * 0.144), 0.8125rem);
      margin-bottom: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 6px;
      line-height: 1.4;
    }
    
    .panel-title .badge {
      font-size: clamp(0.625rem, 0.625rem + ((1vw - 0.48rem) * 0.072), 0.6563rem);
      padding: 2px 6px;
      border-radius: 3px;
    }
    
    .badge.active {
      background: var(--accent);
      color: var(--bg);
    }
    
    .badge.inactive {
      background: #333;
      color: #888;
    }
    
    /* === VIDEO/CANVAS === */
    .video-wrap {
      position: relative;
      background: #000;
      border-radius: 4px;
      overflow: hidden;
      aspect-ratio: 16/9;
    }
    
    .video-wrap video,
    .video-wrap canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    
    /* === CONTROLS === */
    .ctrl-row {
      display: flex;
      gap: 5px;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    
    .ctrl-btn {
      padding: 5px 9px;
      background: var(--hover-bg);
      border: 1px solid #444;
      border-radius: 3px;
      color: var(--text);
      cursor: pointer;
      font-family: inherit;
      font-size: clamp(0.625rem, 0.625rem + ((1vw - 0.48rem) * 0.072), 0.6563rem);
      transition: all 0.15s;
      text-decoration: none;
    }
    
    .ctrl-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
    }
    
    .ctrl-btn:focus {
      outline: 2px dashed var(--accent);
      outline-offset: 2px;
    }
    
    .ctrl-btn:active {
      transform: scale(0.98);
      background: var(--accent);
      color: var(--bg);
    }
    
    .ctrl-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: var(--bg);
    }
    
    .ctrl-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    
    /* === SLIDERS === */
    .slider-group {
      padding: 8px;
      background: var(--hover-bg);
      border-radius: 4px;
      margin-top: 6px;
    }
    
    .slider-label {
      display: flex;
      justify-content: space-between;
      font-size: clamp(0.625rem, 0.625rem + ((1vw - 0.48rem) * 0.072), 0.6563rem);
      margin-bottom: 4px;
      line-height: 1.4;
    }
    
    .slider-label span:last-child {
      color: var(--accent);
    }
    
    input[type="range"] {
      width: 100%;
      height: 3px;
      background: #333;
      border-radius: 2px;
      -webkit-appearance: none;
      margin-top: 2px;
      cursor: pointer;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 11px;
      height: 11px;
      background: var(--accent);
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.15s;
    }
    
    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 0 8px var(--accent);
    }
    
    input[type="range"]::-moz-range-thumb {
      width: 11px;
      height: 11px;
      background: var(--accent);
      border-radius: 50%;
      cursor: pointer;
      border: none;
      transition: all 0.15s;
    }
    
    input[type="range"]::-moz-range-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 0 8px var(--accent);
    }
    
    /* === INFO BOX === */
    .info-box {
      margin-top: 8px;
      padding: 8px;
      background: var(--panel-bg);
      border-radius: 4px;
      font-size: clamp(0.625rem, 0.625rem + ((1vw - 0.48rem) * 0.072), 0.6563rem);
      border-left: 2px solid var(--accent);
      line-height: 1.5;
    }
    
    .info-box strong {
      color: var(--accent);
    }
    
    /* === TIMELINE === */
    .timeline {
      height: 44px;
      background: var(--hover-bg);
      border-radius: 4px;
      position: relative;
      cursor: pointer;
      overflow: hidden;
      transition: all 0.15s;
    }
    
    .timeline:hover {
      background: var(--panel-bg);
    }
    
    .timeline-bar {
      position: absolute;
      bottom: 0;
      min-width: 1px;
      transition: opacity 0.15s;
    }
    
    .timeline-bar.high {
      background: var(--accent);
    }
    
    .timeline-bar.low {
      background: var(--accent-secondary);
      opacity: 0.7;
    }
    
    .playhead {
      position: absolute;
      width: 2px;
      height: 100%;
      background: #fff;
      box-shadow: 0 0 6px #fff;
      z-index: 10;
      pointer-events: none;
    }
    
    .timeline-labels {
      display: flex;
      justify-content: space-between;
      font-size: clamp(0.5625rem, 0.5625rem + ((1vw - 0.48rem) * 0.072), 0.5938rem);
      color: var(--muted);
      margin-top: 3px;
    }
    
    /* === LEGEND === */
    .legend {
      display: flex;
      gap: 12px;
      font-size: clamp(0.625rem, 0.625rem + ((1vw - 0.48rem) * 0.072), 0.6563rem);
      margin-top: 6px;
      flex-wrap: wrap;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    
    .legend-dot {
      width: 8px;
      height: 8px;
      border-radius: 2px;
    }
    
    .legend-dot.high {
      background: var(--accent);
    }
    
    .legend-dot.low {
      background: var(--accent-secondary);
    }
    
    /* === STATS === */
    .stats-row {
      display: flex;
      gap: 8px;
      margin-top: 10px;
    }
    
    .stat-box {
      flex: 1;
      text-align: center;
      padding: 8px 4px;
      background: var(--hover-bg);
      border-radius: 4px;
      transition: all 0.15s;
    }
    
    .stat-box:hover {
      background: var(--panel-bg);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .stat-value {
      font-size: clamp(1rem, 1rem + ((1vw - 0.48rem) * 0.288), 1.125rem);
      font-weight: bold;
      line-height: 1.2;
    }
    
    .stat-value.high {
      color: var(--accent);
    }
    
    .stat-value.low {
      color: var(--accent-secondary);
    }
    
    .stat-value.neutral {
      color: var(--accent-tertiary);
    }
    
    .stat-label {
      font-size: clamp(0.5625rem, 0.5625rem + ((1vw - 0.48rem) * 0.072), 0.5938rem);
      color: #888;
      margin-top: 2px;
    }
    
    /* === METER === */
    .meter {
      height: 14px;
      background: var(--bg);
      border-radius: 3px;
      overflow: hidden;
      position: relative;
    }
    
    .meter-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent-secondary), var(--accent));
      transition: width 0.1s;
    }
    
    .meter-threshold {
      position: absolute;
      top: 0;
      height: 100%;
      width: 2px;
      background: rgba(255, 255, 255, 0.5);
    }
    
    /* === FRAME INDICATOR === */
    .frame-indicator {
      padding: 6px 10px;
      border-radius: 3px;
      text-align: center;
      font-weight: bold;
      font-size: clamp(0.6875rem, 0.6875rem + ((1vw - 0.48rem) * 0.072), 0.7188rem);
      margin-top: 6px;
      line-height: 1.4;
    }
    
    .frame-indicator.high {
      background: rgba(255, 0, 255, 0.15);
      color: var(--accent);
      border: 1px solid rgba(255, 0, 255, 0.4);
    }
    
    .frame-indicator.low {
      background: rgba(0, 188, 212, 0.15);
      color: var(--accent-secondary);
      border: 1px solid rgba(0, 188, 212, 0.4);
    }
    
    /* === TABS === */
    .tab-row {
      display: flex;
      gap: 3px;
      margin-bottom: 8px;
      border-bottom: 1px solid #333;
      padding-bottom: 6px;
    }
    
    .tab-btn {
      padding: 4px 10px;
      background: transparent;
      border: none;
      color: #888;
      cursor: pointer;
      font-family: inherit;
      font-size: clamp(0.625rem, 0.625rem + ((1vw - 0.48rem) * 0.072), 0.6563rem);
      border-radius: 3px 3px 0 0;
      transition: all 0.15s;
      text-decoration: none;
    }
    
    .tab-btn:hover {
      color: var(--text);
      background: rgba(255, 255, 255, 0.05);
    }
    
    .tab-btn:focus {
      outline: 2px dashed var(--accent);
      outline-offset: 2px;
    }
    
    .tab-btn.active {
      background: var(--hover-bg);
      color: var(--accent);
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    /* === STRUCTURE VIEW === */
    .structure-view {
      display: flex;
      flex-wrap: wrap;
      gap: 2px;
      padding: 8px;
      background: var(--bg);
      border-radius: 4px;
      max-height: 110px;
      overflow-y: auto;
    }
    
    .struct-block {
      width: 7px;
      height: 7px;
      border-radius: 1px;
      transition: all 0.15s;
    }
    
    .struct-block.high {
      background: var(--accent);
      box-shadow: 0 0 3px var(--accent);
    }
    
    .struct-block.low {
      background: var(--accent-secondary);
      opacity: 0.6;
    }
    
    .struct-block.deleted {
      opacity: 0.15;
    }
    
    .struct-block.current {
      box-shadow: 0 0 0 1px #fff;
      transform: scale(1.2);
    }
    
    /* === GOP DIAGRAM === */
    .gop-diagram {
      display: flex;
      gap: 2px;
      padding: 10px;
      background: var(--hover-bg);
      border-radius: 4px;
      overflow-x: auto;
      align-items: flex-end;
      min-height: 90px;
    }
    
    .gop-frame {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-width: 14px;
    }
    
    .gop-bar {
      width: 12px;
      border-radius: 2px 2px 0 0;
      transition: height 0.2s, transform 0.15s;
    }
    
    .gop-bar.high {
      background: var(--accent);
      box-shadow: 0 0 4px var(--accent);
    }
    
    .gop-bar:hover {
      transform: scaleX(1.2);
    }
    
    .gop-bar.low {
      background: var(--accent-secondary);
      opacity: 0.7;
    }
    
    .gop-label {
      font-size: clamp(0.5rem, 0.5rem + ((1vw - 0.48rem) * 0.036), 0.5156rem);
      color: var(--muted);
      margin-top: 2px;
    }
    
    /* === EXPORT DATA === */
    .export-data {
      padding: 8px;
      background: var(--bg);
      border-radius: 4px;
      font-size: clamp(0.5625rem, 0.5625rem + ((1vw - 0.48rem) * 0.072), 0.5938rem);
      max-height: 100px;
      overflow-y: auto;
      white-space: pre-wrap;
      word-break: break-all;
      line-height: 1.4;
    }
    
    /* === VECTOR INFO === */
    .vector-info {
      margin-top: 6px;
      font-size: clamp(0.5938rem, 0.5938rem + ((1vw - 0.48rem) * 0.072), 0.625rem);
      color: #888;
      line-height: 1.5;
    }
    
    .vector-info span {
      color: #00ff88;
    }
    
    /* === FOOTER === */
    footer {
      margin-top: clamp(1.5rem, 1.5rem + ((1vw - 0.48rem) * 1.442), 2rem);
      padding-top: 14px;
      border-top: 1px solid var(--border);
      font-size: clamp(0.625rem, 0.625rem + ((1vw - 0.48rem) * 0.072), 0.6563rem);
      color: var(--muted);
      text-align: center;
      line-height: 1.6;
    }
    
    footer a {
      color: var(--accent);
      text-decoration: underline;
      transition: all 0.15s;
    }
    
    footer a:hover {
      text-decoration: none;
      color: var(--hover-text);
    }
    
    footer a:focus {
      text-decoration: underline dashed;
      outline: 2px dashed var(--accent);
      outline-offset: 2px;
    }
    
    footer a:active {
      color: var(--accent);
    }
    
    /* === UTILITY === */
    .hidden {
      display: none !important;
    }
  </style>
</head>
<body class="full-width-content">
  <header>
    <div class="header-content">
      <h1>Datamosh Lab</h1>
      <p class="subtitle">Frame structure analysis + motion vector visualization + bloom/pixel drag simulation</p>
    </div>
    <button class="theme-toggle" id="themeToggle" aria-label="Toggle theme">
      <span id="themeIcon">☀️</span>
      <span id="themeText">Light</span>
    </button>
  </header>

  <div class="upload-area" id="uploadArea">
    <label class="upload-btn"><input type="file" accept="video/*" id="fileInput">Choose Video</label>
    <span style="margin-left:10px;color:#666;font-size:0.72rem">or drag & drop</span>
    <div class="status-msg hidden" id="statusMsg">
      <span id="statusText">Analyzing...</span>
      <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
    </div>
  </div>

  <div id="content" class="hidden">
    <div class="main-grid">
      <!-- COL 1: Original + Analysis -->
      <div>
        <div class="panel">
          <div class="panel-title"><span>Original Video</span><span id="timeDisplay" style="font-size:0.65rem;color:#888">0:00/0:00</span></div>
          <div class="video-wrap"><video id="video" muted playsinline></video></div>
          <div class="ctrl-row">
            <button class="ctrl-btn" id="playBtn">▶ Play</button>
            <button class="ctrl-btn" id="stepBackBtn">← Back</button>
            <button class="ctrl-btn" id="stepBtn">→ Step</button>
            <button class="ctrl-btn" id="resetBtn">↺ Reset</button>
          </div>
        </div>
        
        <div class="panel">
          <div class="panel-title">Real-Time Analysis</div>
          <div class="slider-label"><span>Frame Change</span><span id="changePercent">0%</span></div>
          <div class="meter"><div class="meter-fill" id="changeMeter"></div><div class="meter-threshold" id="threshMarker" style="left:25%"></div></div>
          <div class="frame-indicator low" id="frameIndicator">Waiting...</div>
          <div class="slider-group">
            <div class="slider-label"><span>I-Frame Threshold</span><span id="threshVal">5%</span></div>
            <input type="range" id="threshSlider" min="1" max="20" value="5">
          </div>
        </div>
        
        <div class="panel">
          <div class="panel-title">Timeline</div>
          <div class="timeline" id="timeline"><div class="playhead" id="playhead"></div></div>
          <div class="timeline-labels"><span>0:00</span><span id="durLabel">0:00</span></div>
          <div class="legend">
            <div class="legend-item"><div class="legend-dot high"></div>I-candidate</div>
            <div class="legend-item"><div class="legend-dot low"></div>P-candidate</div>
          </div>
          <div class="stats-row">
            <div class="stat-box"><div class="stat-value high" id="highCount">0</div><div class="stat-label">I-candidates</div></div>
            <div class="stat-box"><div class="stat-value low" id="lowCount">0</div><div class="stat-label">P-candidates</div></div>
            <div class="stat-box"><div class="stat-value neutral" id="totalCount">0</div><div class="stat-label">Total</div></div>
          </div>
        </div>
      </div>

      <!-- COL 2: Motion Vectors -->
      <div>
        <div class="panel">
          <div class="panel-title">Motion Vector Field</div>
          <div class="video-wrap"><canvas id="motionCanvas"></canvas></div>
          <div class="vector-info"><span>→</span> Arrows show motion direction & magnitude per 16×16 block</div>
          <div class="info-box">
            <strong>What you see:</strong> This is what P-frames encode—motion vectors describing where each block moved. Datamoshing applies these vectors to the wrong pixels.
          </div>
        </div>
        
        <div class="panel">
          <div class="tab-row">
            <button class="tab-btn active" data-tab="structure">Structure</button>
            <button class="tab-btn" data-tab="gop">GOP</button>
            <button class="tab-btn" data-tab="export">Export</button>
          </div>
          <div class="tab-content active" id="tab-structure">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
              <span style="font-size:0.68rem;color:#888">Frame Map</span>
              <button class="ctrl-btn" id="bloomToggle" style="padding:3px 8px;font-size:0.6rem">Show Bloom</button>
            </div>
            <div class="structure-view" id="structureView"></div>
          </div>
          <div class="tab-content" id="tab-gop">
            <div class="gop-diagram" id="gopDiagram"></div>
          </div>
          <div class="tab-content" id="tab-export">
            <button class="ctrl-btn" id="copyBtn" style="margin-bottom:6px;font-size:0.6rem">Copy JSON</button>
            <div class="export-data" id="exportData">{}</div>
          </div>
        </div>
      </div>

      <!-- COL 3: Simulation -->
      <div>
        <div class="panel">
          <div class="panel-title">
            <span>Datamosh Simulation</span>
            <span class="badge inactive" id="bloomBadge">MONITORING</span>
          </div>
          <div class="video-wrap"><canvas id="outputCanvas"></canvas></div>
          <div class="ctrl-row">
            <button class="ctrl-btn active" id="btnDrag">Pixel Drag</button>
            <button class="ctrl-btn" id="btnBloom">Bloom</button>
            <button class="ctrl-btn" id="btnCombined">Combined</button>
            <button class="ctrl-btn" id="btnNormal">Normal</button>
          </div>
        </div>
        
        <div class="panel">
          <div class="panel-title">Effect Parameters</div>
          <div class="slider-group">
            <div class="slider-label"><span>Vector Multiplier</span><span id="vecMultVal">3×</span></div>
            <input type="range" id="vecMultSlider" min="1" max="12" value="3">
          </div>
          <div class="slider-group">
            <div class="slider-label"><span>Trail Decay</span><span id="decayVal">5%</span></div>
            <input type="range" id="decaySlider" min="1" max="25" value="5">
          </div>
          <div class="slider-group">
            <div class="slider-label"><span>Color Bleed</span><span id="bleedVal">15%</span></div>
            <input type="range" id="bleedSlider" min="0" max="50" value="15">
          </div>
        </div>
        
        <div class="panel">
          <div class="info-box" style="margin:0">
            <strong>Pixel Drag:</strong> Motion vectors displace pixels directionally; trails accumulate.<br><br>
            <strong>Bloom:</strong> Scene cut freezes frame; new motion vectors displace frozen pixels.
          </div>
        </div>
      </div>
    </div>
  </div>

  <footer>
    Datamosh Lab — A Glitch Pedagogy Tool<br>
    Created by Ernesto Peña | <a href="https://ernestopena.com" target="_blank">ernestopena.com</a>
  </footer>

  <script>
    // === CONFIG ===
    const BLOCK = 16, SEARCH = 16;
    
    // === STATE ===
    let frames = [], duration = 0, threshold = 5, currentIdx = 0;
    let storedMotionFields = []; // Store motion vectors from analysis
    let isPlaying = false, analysisComplete = false, showBloom = false;
    
    let mode = 'drag', vecMult = 3, trailDecay = 0.05, colorBleed = 0.15;
    let prevFrameData = null, motionField = null;
    let frozenFrame = null, isBloomActive = false, bloomAge = 0;

    // === DOM ===
    const video = document.getElementById('video');
    const motionCanvas = document.getElementById('motionCanvas'), motionCtx = motionCanvas.getContext('2d');
    const outputCanvas = document.getElementById('outputCanvas'), outputCtx = outputCanvas.getContext('2d', { willReadFrequently: true });
    
    const workCanvas = document.createElement('canvas'), workCtx = workCanvas.getContext('2d', { willReadFrequently: true });
    const analysisCanvas = document.createElement('canvas'), analysisCtx = analysisCanvas.getContext('2d', { willReadFrequently: true });

    // === FILE ===
    document.getElementById('fileInput').addEventListener('change', function(e) { 
      if (e.target.files[0]) loadVideo(e.target.files[0]); 
    });
    var uploadArea = document.getElementById('uploadArea');
    uploadArea.addEventListener('dragover', function(e) { e.preventDefault(); uploadArea.classList.add('dragover'); });
    uploadArea.addEventListener('dragleave', function() { uploadArea.classList.remove('dragover'); });
    uploadArea.addEventListener('drop', function(e) { 
      e.preventDefault(); 
      uploadArea.classList.remove('dragover'); 
      if (e.dataTransfer.files[0] && e.dataTransfer.files[0].type.startsWith('video/')) {
        loadVideo(e.dataTransfer.files[0]); 
      }
    });

    function loadVideo(file) {
      video.src = URL.createObjectURL(file);
      video.addEventListener('loadedmetadata', function() {
        var w = video.videoWidth, h = video.videoHeight;
        motionCanvas.width = w; motionCanvas.height = h;
        outputCanvas.width = w; outputCanvas.height = h;
        workCanvas.width = w; workCanvas.height = h;
        analysisCanvas.width = 160; 
        analysisCanvas.height = Math.round(h/w*160);
        duration = video.duration;
        document.getElementById('content').classList.remove('hidden');
        document.getElementById('durLabel').textContent = formatTime(duration);
        analyzeVideo();
      }, { once: true });
    }

    // === ANALYSIS ===
    // Mini motion estimation for analysis (smaller blocks for speed)
    function estimateMotionMini(prev, curr, w, h) {
      var blockSize = 8;
      var searchRange = 8;
      var bx = Math.floor(w / blockSize);
      var by = Math.floor(h / blockSize);
      var field = [];
      
      for (var y = 0; y < by; y++) {
        for (var x = 0; x < bx; x++) {
          var ox = x * blockSize;
          var oy = y * blockSize;
          var bestDx = 0, bestDy = 0, bestSAD = Infinity;
          
          // Search for best match
          for (var dy = -searchRange; dy <= searchRange; dy += 2) {
            for (var dx = -searchRange; dx <= searchRange; dx += 2) {
              var tx = ox + dx, ty = oy + dy;
              if (tx < 0 || ty < 0 || tx + blockSize > w || ty + blockSize > h) continue;
              
              var sad = 0;
              for (var py = 0; py < blockSize; py += 2) {
                for (var px = 0; px < blockSize; px += 2) {
                  var i1 = ((oy + py) * w + (ox + px)) * 4;
                  var i2 = ((ty + py) * w + (tx + px)) * 4;
                  sad += Math.abs(curr[i1] - prev[i2]) + Math.abs(curr[i1+1] - prev[i2+1]) + Math.abs(curr[i1+2] - prev[i2+2]);
                }
              }
              
              if (sad < bestSAD) {
                bestSAD = sad;
                bestDx = dx;
                bestDy = dy;
              }
            }
          }
          
          field.push({ x: ox + blockSize/2, y: oy + blockSize/2, dx: bestDx, dy: bestDy });
        }
      }
      return field;
    }

    function analyzeVideo() {
      frames = [];
      storedMotionFields = [];
      document.getElementById('statusMsg').classList.remove('hidden');
      document.getElementById('statusText').textContent = 'Analyzing frames & motion...';
      
      var fps = 30;
      var total = Math.min(Math.floor(duration * fps), 500);
      var frameIndex = 0;
      var lastDataArray = null;
      var isProcessing = false;
      var maxChangeFound = 0;
      var minChangeFound = 100;
      
      function handleSeeked() {
        if (isProcessing) return;
        isProcessing = true;
        
        analysisCtx.drawImage(video, 0, 0, analysisCanvas.width, analysisCanvas.height);
        var currImageData = analysisCtx.getImageData(0, 0, analysisCanvas.width, analysisCanvas.height);
        var currArray = currImageData.data;
        
        if (frameIndex === 0) {
          frames.push({ time: 0, change: 100, index: 0 });
          storedMotionFields.push([]); // No motion for first frame
        } else if (lastDataArray) {
          var diff = 0;
          var pixelCount = 0;
          for (var j = 0; j < currArray.length; j += 16) {
            diff += Math.abs(currArray[j] - lastDataArray[j]);
            diff += Math.abs(currArray[j+1] - lastDataArray[j+1]);
            diff += Math.abs(currArray[j+2] - lastDataArray[j+2]);
            pixelCount++;
          }
          var avgDiff = diff / (pixelCount * 3);
          var change = (avgDiff / 255) * 100;
          
          if (change > maxChangeFound) maxChangeFound = change;
          if (change < minChangeFound && change > 0) minChangeFound = change;
          
          frames.push({ time: frameIndex/fps, change: change, index: frameIndex });
          
          // Compute and store motion field for this frame
          var motionField = estimateMotionMini(lastDataArray, currArray, analysisCanvas.width, analysisCanvas.height);
          storedMotionFields.push(motionField);
        }
        
        lastDataArray = new Uint8ClampedArray(currArray);
        
        document.getElementById('progressFill').style.width = ((frameIndex/total)*100) + '%';
        frameIndex++;
        
        if (frameIndex >= total) {
          video.removeEventListener('seeked', handleSeeked);
          console.log('Analysis complete. Change range:', minChangeFound.toFixed(2) + '% to ' + maxChangeFound.toFixed(2) + '%');
          console.log('Motion fields stored:', storedMotionFields.length);
          document.getElementById('statusText').textContent = 'Done: ' + frames.length + ' frames';
          analysisComplete = true;
          video.currentTime = 0;
          resetSim();
          updateAllUI();
          setTimeout(function() { 
            document.getElementById('statusMsg').classList.add('hidden'); 
          }, 1200);
        } else {
          isProcessing = false;
          video.currentTime = frameIndex / fps;
        }
      }
      
      video.addEventListener('seeked', handleSeeked);
      video.currentTime = 0;
    }

    // === UI ===
    const formatTime = function(s) { return Math.floor(s/60) + ':' + Math.floor(s%60).toString().padStart(2,'0'); };

    function updateAllUI() {
      if (frames.length === 0) {
        console.log('No frames to display');
        return;
      }
      console.log('Updating UI with', frames.length, 'frames');
      
      // Timeline
      const tl = document.getElementById('timeline');
      const ph = document.getElementById('playhead');
      const existingBars = tl.querySelectorAll('.timeline-bar');
      for (let i = 0; i < existingBars.length; i++) existingBars[i].remove();
      
      let maxChange = 1;
      for (let i = 0; i < frames.length; i++) {
        if (frames[i].change > maxChange) maxChange = frames[i].change;
      }
      
      for (let i = 0; i < frames.length; i++) {
        const f = frames[i];
        const bar = document.createElement('div');
        const type = f.change >= threshold ? 'high' : 'low';
        bar.className = 'timeline-bar ' + type;
        bar.style.left = ((f.time / duration) * 100) + '%';
        bar.style.height = ((f.change / maxChange) * 100) + '%';
        bar.style.width = Math.max(100 / frames.length, 0.4) + '%';
        tl.insertBefore(bar, ph);
      }
      
      // Stats
      let highCount = 0;
      for (let i = 0; i < frames.length; i++) {
        if (frames[i].change >= threshold) highCount++;
      }
      document.getElementById('highCount').textContent = highCount;
      document.getElementById('lowCount').textContent = frames.length - highCount;
      document.getElementById('totalCount').textContent = frames.length;
      
      // Update other views
      updateStructure();
      updateGOP();
      updateExport();
    }

    function updateStructure() {
      const container = document.getElementById('structureView');
      if (!container || frames.length === 0) return;
      container.innerHTML = '';
      for (let i = 0; i < frames.length; i++) {
        const f = frames[i];
        const block = document.createElement('div');
        const type = f.change >= threshold ? 'high' : 'low';
        block.className = 'struct-block ' + type;
        if (showBloom && type === 'high' && i > 0) block.className += ' deleted';
        if (i === currentIdx) block.className += ' current';
        container.appendChild(block);
      }
      console.log('Structure updated:', frames.length, 'blocks');
    }

    function updateGOP() {
      const container = document.getElementById('gopDiagram');
      if (!container || frames.length === 0) return;
      container.innerHTML = '';
      const displayFrames = frames.slice(0, 35);
      let maxChange = 1;
      for (let i = 0; i < displayFrames.length; i++) {
        if (displayFrames[i].change > maxChange) maxChange = displayFrames[i].change;
      }
      for (let i = 0; i < displayFrames.length; i++) {
        const f = displayFrames[i];
        const type = f.change >= threshold ? 'high' : 'low';
        const height = Math.max((f.change / maxChange) * 45, 3);
        const frameEl = document.createElement('div');
        frameEl.className = 'gop-frame';
        
        const bar = document.createElement('div');
        bar.className = 'gop-bar ' + type;
        bar.style.height = height + 'px';
        
        const label = document.createElement('div');
        label.className = 'gop-label';
        label.textContent = i;
        
        frameEl.appendChild(bar);
        frameEl.appendChild(label);
        container.appendChild(frameEl);
      }
      console.log('GOP updated:', displayFrames.length, 'frames');
    }

    function updateExport() {
      if (frames.length === 0) return;
      let iCandidates = 0;
      const frameData = [];
      for (let i = 0; i < frames.length; i++) {
        const f = frames[i];
        const type = f.change >= threshold ? 'I' : 'P';
        if (type === 'I') iCandidates++;
        frameData.push({ i: f.index, t: parseFloat(f.time.toFixed(3)), c: parseFloat(f.change.toFixed(2)), type: type });
      }
      const data = {
        meta: { tool: "Datamosh Lab", author: "Ernesto Peña", date: new Date().toISOString(), duration: duration, threshold: threshold, frames: frames.length },
        stats: { iCandidates: iCandidates, pCandidates: frames.length - iCandidates },
        frames: frameData
      };
      document.getElementById('exportData').textContent = JSON.stringify(data, null, 2);
    }

    // === STEP RENDERING ===
    function renderSteppedFrame(frameIdx) {
      if (frameIdx < 0 || frameIdx >= frames.length) return;
      
      var w = outputCanvas.width, h = outputCanvas.height;
      var analysisW = analysisCanvas.width, analysisH = analysisCanvas.height;
      var scaleX = w / analysisW, scaleY = h / analysisH;
      
      // Get stored motion field and scale it up
      var storedField = storedMotionFields[frameIdx] || [];
      var scaledField = [];
      
      for (var i = 0; i < storedField.length; i++) {
        var v = storedField[i];
        scaledField.push({
          x: v.x * scaleX,
          y: v.y * scaleY,
          dx: v.dx * scaleX,
          dy: v.dy * scaleY
        });
      }
      
      // Draw motion field visualization
      drawMotionFieldScaled(scaledField, scaleX);
      
      // Get current frame data
      workCtx.drawImage(video, 0, 0, w, h);
      var currData = workCtx.getImageData(0, 0, w, h).data;
      
      // Get frame change value
      var frameChange = frames[frameIdx] ? frames[frameIdx].change : 0;
      
      // Update meter display
      document.getElementById('changeMeter').style.width = Math.min(frameChange * 5, 100) + '%';
      document.getElementById('changePercent').textContent = frameChange.toFixed(1) + '%';
      var type = frameChange >= threshold ? 'high' : 'low';
      document.getElementById('frameIndicator').className = 'frame-indicator ' + type;
      document.getElementById('frameIndicator').textContent = type === 'high' ? 'HIGH — I-Frame Candidate' : 'Low — P-Frame Candidate';
      
      // Apply simulation effect using scaled field
      if (scaledField.length > 0) {
        switch (mode) {
          case 'drag': 
            applyDragWithField(currData, scaledField, w, h, scaleX); 
            break;
          case 'bloom': 
            applyBloomWithField(currData, scaledField, w, h, frameChange, scaleX); 
            break;
          case 'combined': 
            applyCombinedWithField(currData, scaledField, w, h, frameChange, scaleX); 
            break;
          default: 
            outputCtx.drawImage(video, 0, 0);
        }
      } else {
        outputCtx.drawImage(video, 0, 0);
      }
      
      // Store for next step
      prevFrameData = new Uint8ClampedArray(currData);
    }
    
    function drawMotionFieldScaled(field, scale) {
      motionCtx.fillStyle = 'rgba(0,0,0,0.75)';
      motionCtx.fillRect(0, 0, motionCanvas.width, motionCanvas.height);
      motionCtx.globalAlpha = 0.25;
      motionCtx.drawImage(video, 0, 0);
      motionCtx.globalAlpha = 1;
      motionCtx.strokeStyle = '#00ff88';
      motionCtx.lineWidth = 1.5;
      
      for (var i = 0; i < field.length; i++) {
        var v = field[i];
        var mag = Math.sqrt(v.dx*v.dx + v.dy*v.dy);
        if (mag < 1 * scale) continue;
        
        motionCtx.beginPath();
        motionCtx.moveTo(v.x, v.y);
        motionCtx.lineTo(v.x + v.dx*2, v.y + v.dy*2);
        motionCtx.stroke();
        
        var a = Math.atan2(v.dy, v.dx);
        motionCtx.beginPath();
        motionCtx.moveTo(v.x + v.dx*2, v.y + v.dy*2);
        motionCtx.lineTo(v.x + v.dx*2 - 4*Math.cos(a-0.5), v.y + v.dy*2 - 4*Math.sin(a-0.5));
        motionCtx.moveTo(v.x + v.dx*2, v.y + v.dy*2);
        motionCtx.lineTo(v.x + v.dx*2 - 4*Math.cos(a+0.5), v.y + v.dy*2 - 4*Math.sin(a+0.5));
        motionCtx.stroke();
      }
    }
    
    function applyDragWithField(curr, field, w, h, scale) {
      var ex = outputCtx.getImageData(0, 0, w, h);
      var blockSize = 8 * scale;
      var bx = Math.floor(w / blockSize);
      
      for (var i = 0; i < ex.data.length; i += 4) { 
        ex.data[i] *= (1-trailDecay); 
        ex.data[i+1] *= (1-trailDecay); 
        ex.data[i+2] *= (1-trailDecay); 
      }
      
      for (var y = 0; y < h; y++) {
        for (var x = 0; x < w; x++) {
          var bi = Math.floor(y / blockSize) * bx + Math.floor(x / blockSize);
          if (bi >= field.length) continue;
          var v = field[bi];
          var sx = Math.max(0, Math.min(w-1, x - v.dx * vecMult));
          var sy = Math.max(0, Math.min(h-1, y - v.dy * vecMult));
          var si = (Math.floor(sy) * w + Math.floor(sx)) * 4;
          var di = (y * w + x) * 4;
          var mag = Math.sqrt(v.dx*v.dx + v.dy*v.dy) / (8 * scale);
          var blend = Math.min(0.8, 0.3 + mag);
          ex.data[di] = ex.data[di]*(1-blend) + curr[si]*blend;
          ex.data[di+1] = ex.data[di+1]*(1-blend) + curr[si+1]*blend;
          ex.data[di+2] = ex.data[di+2]*(1-blend) + curr[si+2]*blend;
          ex.data[di+3] = 255;
        }
      }
      outputCtx.putImageData(ex, 0, 0);
    }
    
    function applyBloomWithField(curr, field, w, h, change, scale) {
      if (change >= threshold && !isBloomActive) {
        frozenFrame = outputCtx.getImageData(0, 0, w, h);
        var sum = 0; 
        for (var i = 0; i < 1000; i += 4) sum += frozenFrame.data[i];
        if (sum < 100 && prevFrameData) frozenFrame = new ImageData(new Uint8ClampedArray(prevFrameData), w, h);
        isBloomActive = true; 
        bloomAge = 0; 
        updateBloomBadge();
      }
      
      if (isBloomActive && frozenFrame) {
        var out = new ImageData(w, h);
        var blockSize = 8 * scale;
        var bx = Math.floor(w / blockSize);
        var decay = Math.max(0, 1 - bloomAge * 0.012);
        
        for (var y = 0; y < h; y++) {
          for (var x = 0; x < w; x++) {
            var bi = Math.floor(y / blockSize) * bx + Math.floor(x / blockSize);
            var v = bi < field.length ? field[bi] : {dx:0, dy:0};
            var sx = Math.max(0, Math.min(w-1, x - v.dx * vecMult * decay));
            var sy = Math.max(0, Math.min(h-1, y - v.dy * vecMult * decay));
            var si = (Math.floor(sy) * w + Math.floor(sx)) * 4;
            var di = (y * w + x) * 4;
            var bleed = colorBleed * decay;
            out.data[di] = frozenFrame.data[si]*(1-bleed) + curr[di]*bleed;
            out.data[di+1] = frozenFrame.data[si+1]*(1-bleed) + curr[di+1]*bleed;
            out.data[di+2] = frozenFrame.data[si+2]*(1-bleed) + curr[di+2]*bleed;
            out.data[di+3] = 255;
          }
        }
        outputCtx.putImageData(out, 0, 0);
        frozenFrame = out; 
        bloomAge++;
        if (decay < 0.1) { isBloomActive = false; updateBloomBadge(); }
      } else {
        outputCtx.drawImage(video, 0, 0);
      }
    }
    
    function applyCombinedWithField(curr, field, w, h, change, scale) {
      if (change >= threshold && !isBloomActive) {
        frozenFrame = outputCtx.getImageData(0, 0, w, h);
        var sum = 0; 
        for (var i = 0; i < 1000; i += 4) sum += frozenFrame.data[i];
        if (sum < 100 && prevFrameData) frozenFrame = new ImageData(new Uint8ClampedArray(prevFrameData), w, h);
        isBloomActive = true; 
        bloomAge = 0; 
        updateBloomBadge();
      }
      
      var ex = outputCtx.getImageData(0, 0, w, h);
      var blockSize = 8 * scale;
      var bx = Math.floor(w / blockSize);
      var decay = isBloomActive ? Math.max(0, 1 - bloomAge * 0.01) : 0;
      
      for (var i = 0; i < ex.data.length; i += 4) { 
        ex.data[i] *= (1-trailDecay*0.5); 
        ex.data[i+1] *= (1-trailDecay*0.5); 
        ex.data[i+2] *= (1-trailDecay*0.5); 
      }
      
      var src = isBloomActive && frozenFrame ? frozenFrame.data : curr;
      
      for (var y = 0; y < h; y++) {
        for (var x = 0; x < w; x++) {
          var bi = Math.floor(y / blockSize) * bx + Math.floor(x / blockSize);
          var v = bi < field.length ? field[bi] : {dx:0, dy:0};
          var mult = isBloomActive ? vecMult * (1 + decay) : vecMult;
          var sx = Math.max(0, Math.min(w-1, x - v.dx * mult));
          var sy = Math.max(0, Math.min(h-1, y - v.dy * mult));
          var si = (Math.floor(sy) * w + Math.floor(sx)) * 4;
          var di = (y * w + x) * 4;
          var mag = Math.sqrt(v.dx*v.dx + v.dy*v.dy) / (8 * scale);
          var blend = Math.min(0.7, 0.2 + mag);
          var r = src[si], g = src[si+1], b = src[si+2];
          if (isBloomActive) { 
            var bl = colorBleed * decay; 
            r = r*(1-bl) + curr[di]*bl; 
            g = g*(1-bl) + curr[di+1]*bl; 
            b = b*(1-bl) + curr[di+2]*bl; 
          }
          ex.data[di] = ex.data[di]*(1-blend) + r*blend;
          ex.data[di+1] = ex.data[di+1]*(1-blend) + g*blend;
          ex.data[di+2] = ex.data[di+2]*(1-blend) + b*blend;
          ex.data[di+3] = 255;
        }
      }
      outputCtx.putImageData(ex, 0, 0);
      if (isBloomActive) { frozenFrame = ex; bloomAge++; if (decay < 0.05) { isBloomActive = false; updateBloomBadge(); } }
    }

    // === MOTION ESTIMATION ===
    function estimateMotion(prev, curr, w, h) {
      const bx = Math.floor(w/BLOCK), by = Math.floor(h/BLOCK), field = [];
      for (let y = 0; y < by; y++) {
        for (let x = 0; x < bx; x++) {
          const ox = x*BLOCK, oy = y*BLOCK;
          let bestDx = 0, bestDy = 0, bestSAD = Infinity;
          for (let dy = -SEARCH; dy <= SEARCH; dy += 2) {
            for (let dx = -SEARCH; dx <= SEARCH; dx += 2) {
              const tx = ox+dx, ty = oy+dy;
              if (tx < 0 || ty < 0 || tx+BLOCK > w || ty+BLOCK > h) continue;
              let sad = 0;
              for (let py = 0; py < BLOCK; py += 2) {
                for (let px = 0; px < BLOCK; px += 2) {
                  const i1 = ((oy+py)*w+(ox+px))*4, i2 = ((ty+py)*w+(tx+px))*4;
                  sad += Math.abs(curr[i1]-prev[i2]) + Math.abs(curr[i1+1]-prev[i2+1]) + Math.abs(curr[i1+2]-prev[i2+2]);
                }
              }
              if (sad < bestSAD) { bestSAD = sad; bestDx = dx; bestDy = dy; }
            }
          }
          field.push({ x: ox+BLOCK/2, y: oy+BLOCK/2, dx: bestDx, dy: bestDy });
        }
      }
      return field;
    }

    function calcSceneChange(field) {
      let total = 0;
      field.forEach(v => total += Math.sqrt(v.dx*v.dx + v.dy*v.dy));
      return (total / field.length) / SEARCH * 100;
    }

    // === RENDERING ===
    function drawMotionField(field) {
      motionCtx.fillStyle = 'rgba(0,0,0,0.75)';
      motionCtx.fillRect(0, 0, motionCanvas.width, motionCanvas.height);
      motionCtx.globalAlpha = 0.25;
      motionCtx.drawImage(video, 0, 0);
      motionCtx.globalAlpha = 1;
      motionCtx.strokeStyle = '#00ff88';
      motionCtx.lineWidth = 1.5;
      field.forEach(v => {
        const mag = Math.sqrt(v.dx*v.dx + v.dy*v.dy);
        if (mag < 1) return;
        motionCtx.beginPath();
        motionCtx.moveTo(v.x, v.y);
        motionCtx.lineTo(v.x + v.dx*2, v.y + v.dy*2);
        motionCtx.stroke();
        const a = Math.atan2(v.dy, v.dx);
        motionCtx.beginPath();
        motionCtx.moveTo(v.x + v.dx*2, v.y + v.dy*2);
        motionCtx.lineTo(v.x + v.dx*2 - 4*Math.cos(a-0.5), v.y + v.dy*2 - 4*Math.sin(a-0.5));
        motionCtx.moveTo(v.x + v.dx*2, v.y + v.dy*2);
        motionCtx.lineTo(v.x + v.dx*2 - 4*Math.cos(a+0.5), v.y + v.dy*2 - 4*Math.sin(a+0.5));
        motionCtx.stroke();
      });
    }

    function applyDrag(curr, field, w, h) {
      const ex = outputCtx.getImageData(0, 0, w, h), bx = Math.floor(w/BLOCK);
      for (let i = 0; i < ex.data.length; i += 4) { ex.data[i] *= (1-trailDecay); ex.data[i+1] *= (1-trailDecay); ex.data[i+2] *= (1-trailDecay); }
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const bi = Math.floor(y/BLOCK)*bx + Math.floor(x/BLOCK);
          if (bi >= field.length) continue;
          const v = field[bi];
          const sx = Math.max(0, Math.min(w-1, x - v.dx*vecMult)), sy = Math.max(0, Math.min(h-1, y - v.dy*vecMult));
          const si = (Math.floor(sy)*w + Math.floor(sx))*4, di = (y*w+x)*4;
          const mag = Math.sqrt(v.dx*v.dx + v.dy*v.dy) / SEARCH;
          const blend = Math.min(0.8, 0.3 + mag);
          ex.data[di] = ex.data[di]*(1-blend) + curr[si]*blend;
          ex.data[di+1] = ex.data[di+1]*(1-blend) + curr[si+1]*blend;
          ex.data[di+2] = ex.data[di+2]*(1-blend) + curr[si+2]*blend;
          ex.data[di+3] = 255;
        }
      }
      outputCtx.putImageData(ex, 0, 0);
    }

    function applyBloomEffect(curr, field, w, h, sc) {
      if (sc > threshold && !isBloomActive) {
        frozenFrame = outputCtx.getImageData(0, 0, w, h);
        let sum = 0; for (let i = 0; i < 1000; i += 4) sum += frozenFrame.data[i];
        if (sum < 100 && prevFrameData) frozenFrame = new ImageData(new Uint8ClampedArray(prevFrameData), w, h);
        isBloomActive = true; bloomAge = 0; updateBloomBadge();
      }
      if (isBloomActive && frozenFrame) {
        const out = new ImageData(w, h), bx = Math.floor(w/BLOCK);
        const decay = Math.max(0, 1 - bloomAge*0.012);
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            const bi = Math.floor(y/BLOCK)*bx + Math.floor(x/BLOCK);
            const v = bi < field.length ? field[bi] : {dx:0, dy:0};
            const sx = Math.max(0, Math.min(w-1, x - v.dx*vecMult*decay)), sy = Math.max(0, Math.min(h-1, y - v.dy*vecMult*decay));
            const si = (Math.floor(sy)*w + Math.floor(sx))*4, di = (y*w+x)*4;
            const bleed = colorBleed * decay;
            out.data[di] = frozenFrame.data[si]*(1-bleed) + curr[di]*bleed;
            out.data[di+1] = frozenFrame.data[si+1]*(1-bleed) + curr[di+1]*bleed;
            out.data[di+2] = frozenFrame.data[si+2]*(1-bleed) + curr[di+2]*bleed;
            out.data[di+3] = 255;
          }
        }
        outputCtx.putImageData(out, 0, 0);
        frozenFrame = out; bloomAge++;
        if (decay < 0.1) { isBloomActive = false; updateBloomBadge(); }
      } else {
        outputCtx.drawImage(video, 0, 0);
      }
    }

    function applyCombined(curr, field, w, h, sc) {
      if (sc > threshold && !isBloomActive) {
        frozenFrame = outputCtx.getImageData(0, 0, w, h);
        let sum = 0; for (let i = 0; i < 1000; i += 4) sum += frozenFrame.data[i];
        if (sum < 100 && prevFrameData) frozenFrame = new ImageData(new Uint8ClampedArray(prevFrameData), w, h);
        isBloomActive = true; bloomAge = 0; updateBloomBadge();
      }
      const ex = outputCtx.getImageData(0, 0, w, h), bx = Math.floor(w/BLOCK);
      const decay = isBloomActive ? Math.max(0, 1 - bloomAge*0.01) : 0;
      for (let i = 0; i < ex.data.length; i += 4) { ex.data[i] *= (1-trailDecay*0.5); ex.data[i+1] *= (1-trailDecay*0.5); ex.data[i+2] *= (1-trailDecay*0.5); }
      const src = isBloomActive && frozenFrame ? frozenFrame.data : curr;
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const bi = Math.floor(y/BLOCK)*bx + Math.floor(x/BLOCK);
          const v = bi < field.length ? field[bi] : {dx:0,dy:0};
          const mult = isBloomActive ? vecMult*(1+decay) : vecMult;
          const sx = Math.max(0, Math.min(w-1, x - v.dx*mult)), sy = Math.max(0, Math.min(h-1, y - v.dy*mult));
          const si = (Math.floor(sy)*w + Math.floor(sx))*4, di = (y*w+x)*4;
          const mag = Math.sqrt(v.dx*v.dx + v.dy*v.dy)/SEARCH;
          const blend = Math.min(0.7, 0.2+mag);
          let r = src[si], g = src[si+1], b = src[si+2];
          if (isBloomActive) { const bl = colorBleed*decay; r = r*(1-bl)+curr[di]*bl; g = g*(1-bl)+curr[di+1]*bl; b = b*(1-bl)+curr[di+2]*bl; }
          ex.data[di] = ex.data[di]*(1-blend) + r*blend;
          ex.data[di+1] = ex.data[di+1]*(1-blend) + g*blend;
          ex.data[di+2] = ex.data[di+2]*(1-blend) + b*blend;
          ex.data[di+3] = 255;
        }
      }
      outputCtx.putImageData(ex, 0, 0);
      if (isBloomActive) { frozenFrame = ex; bloomAge++; if (decay < 0.05) { isBloomActive = false; updateBloomBadge(); } }
    }

    function updateBloomBadge() {
      var b = document.getElementById('bloomBadge');
      if (isBloomActive) {
        b.className = 'badge active';
        b.textContent = 'BLOOM ACTIVE';
      } else {
        b.className = 'badge inactive';
        b.textContent = 'MONITORING';
      }
    }

    function resetSim() {
      prevFrameData = null; motionField = null; frozenFrame = null;
      isBloomActive = false; bloomAge = 0;
      outputCtx.fillStyle = '#000';
      outputCtx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
      motionCtx.fillStyle = '#000';
      motionCtx.fillRect(0, 0, motionCanvas.width, motionCanvas.height);
      updateBloomBadge();
    }

    // === MAIN LOOP ===
    function processFrame() {
      if (!isPlaying) return;
      const w = workCanvas.width, h = workCanvas.height;
      
      workCtx.drawImage(video, 0, 0, w, h);
      const curr = workCtx.getImageData(0, 0, w, h).data;
      
      // Update time display
      var t = video.currentTime;
      document.getElementById('timeDisplay').textContent = formatTime(t) + '/' + formatTime(duration);
      document.getElementById('playhead').style.left = ((t/duration)*100) + '%';
      
      // Find current analysis frame
      for (let i = frames.length-1; i >= 0; i--) { if (frames[i].time <= t) { currentIdx = i; break; } }
      
      if (prevFrameData) {
        motionField = estimateMotion(prevFrameData, curr, w, h);
        const sc = calcSceneChange(motionField);
        
        // Update meter
        document.getElementById('changeMeter').style.width = Math.min(sc, 100) + '%';
        document.getElementById('changePercent').textContent = sc.toFixed(1) + '%';
        const type = sc >= threshold ? 'high' : 'low';
        document.getElementById('frameIndicator').className = 'frame-indicator ' + type;
        document.getElementById('frameIndicator').textContent = type === 'high' ? 'HIGH — I-Frame Candidate' : 'Low — P-Frame Candidate';
        
        drawMotionField(motionField);
        
        switch (mode) {
          case 'drag': applyDrag(curr, motionField, w, h); break;
          case 'bloom': applyBloomEffect(curr, motionField, w, h, sc); break;
          case 'combined': applyCombined(curr, motionField, w, h, sc); break;
          default: outputCtx.drawImage(video, 0, 0);
        }
      } else {
        outputCtx.drawImage(video, 0, 0);
      }
      
      prevFrameData = new Uint8ClampedArray(curr);
      requestAnimationFrame(processFrame);
    }

    // === CONTROLS ===
    document.getElementById('playBtn').addEventListener('click', function() {
      if (isPlaying) { 
        video.pause(); 
        isPlaying = false; 
        document.getElementById('playBtn').textContent = '▶ Play'; 
      } else { 
        video.play(); 
        isPlaying = true; 
        document.getElementById('playBtn').textContent = '❚❚'; 
        requestAnimationFrame(processFrame); 
      }
    });
    document.getElementById('stepBackBtn').addEventListener('click', function() { 
      video.pause(); 
      isPlaying = false; 
      document.getElementById('playBtn').textContent = '▶ Play'; 
      
      // Go back one frame
      video.currentTime = Math.max(0, video.currentTime - 1/30);
      
      // Find corresponding frame index
      var targetTime = video.currentTime;
      var frameIdx = 0;
      for (var i = 0; i < frames.length; i++) {
        if (frames[i].time <= targetTime) {
          frameIdx = i;
        } else {
          break;
        }
      }
      currentIdx = frameIdx;
      
      // Wait for seek then render
      video.onseeked = function() {
        video.onseeked = null;
        document.getElementById('timeDisplay').textContent = formatTime(video.currentTime) + '/' + formatTime(duration);
        document.getElementById('playhead').style.left = ((video.currentTime / duration) * 100) + '%';
        renderSteppedFrame(frameIdx);
        updateStructure();
      };
    });
    document.getElementById('stepBtn').addEventListener('click', function() { 
      video.pause(); 
      isPlaying = false; 
      document.getElementById('playBtn').textContent = '▶ Play'; 
      
      // Advance by one frame
      video.currentTime += 1/30;
      
      // Find corresponding frame index
      var targetTime = video.currentTime;
      var frameIdx = 0;
      for (var i = 0; i < frames.length; i++) {
        if (frames[i].time <= targetTime) {
          frameIdx = i;
        } else {
          break;
        }
      }
      currentIdx = frameIdx;
      
      // Wait for seek then render
      video.onseeked = function() {
        video.onseeked = null;
        
        // Update time display
        document.getElementById('timeDisplay').textContent = formatTime(video.currentTime) + '/' + formatTime(duration);
        document.getElementById('playhead').style.left = ((video.currentTime / duration) * 100) + '%';
        
        // Render using stored motion data
        renderSteppedFrame(frameIdx);
        
        // Update structure view to highlight current frame
        updateStructure();
      };
    });
    document.getElementById('resetBtn').addEventListener('click', function() { 
      video.pause(); 
      video.currentTime = 0; 
      isPlaying = false; 
      document.getElementById('playBtn').textContent = '▶ Play'; 
      resetSim(); 
      updateStructure(); 
    });

    ['btnDrag','btnBloom','btnCombined','btnNormal'].forEach(function(id) {
      document.getElementById(id).addEventListener('click', function() {
        mode = id.replace('btn','').toLowerCase();
        ['btnDrag','btnBloom','btnCombined','btnNormal'].forEach(function(b) { 
          document.getElementById(b).classList.remove('active'); 
        });
        document.getElementById(id).classList.add('active');
        resetSim();
      });
    });

    document.getElementById('threshSlider').addEventListener('input', function(e) { 
      threshold = parseInt(e.target.value); 
      document.getElementById('threshVal').textContent = threshold + '%'; 
      // Position marker as percentage of 20 (max slider value)
      document.getElementById('threshMarker').style.left = ((threshold / 20) * 100) + '%'; 
      if (analysisComplete) updateAllUI(); 
    });
    document.getElementById('vecMultSlider').addEventListener('input', function(e) { vecMult = parseInt(e.target.value); document.getElementById('vecMultVal').textContent = e.target.value + '×'; });
    document.getElementById('decaySlider').addEventListener('input', function(e) { trailDecay = e.target.value/100; document.getElementById('decayVal').textContent = e.target.value + '%'; });
    document.getElementById('bleedSlider').addEventListener('input', function(e) { colorBleed = e.target.value/100; document.getElementById('bleedVal').textContent = e.target.value + '%'; });

    var tabBtns = document.querySelectorAll('.tab-btn');
    for (var i = 0; i < tabBtns.length; i++) {
      tabBtns[i].addEventListener('click', function(e) {
        var allBtns = document.querySelectorAll('.tab-btn');
        var allContents = document.querySelectorAll('.tab-content');
        for (var j = 0; j < allBtns.length; j++) allBtns[j].classList.remove('active');
        for (var j = 0; j < allContents.length; j++) allContents[j].classList.remove('active');
        e.target.classList.add('active');
        document.getElementById('tab-' + e.target.getAttribute('data-tab')).classList.add('active');
      });
    }

    document.getElementById('bloomToggle').addEventListener('click', function() { 
      showBloom = !showBloom; 
      this.textContent = showBloom ? 'Normal' : 'Show Bloom'; 
      if (showBloom) {
        this.classList.add('active');
      } else {
        this.classList.remove('active');
      }
      updateStructure(); 
    });
    document.getElementById('timeline').addEventListener('click', function(e) { 
      if (!duration) return; 
      var rect = document.getElementById('timeline').getBoundingClientRect();
      var targetTime = ((e.clientX - rect.left) / rect.width) * duration;
      video.currentTime = targetTime;
      
      // If not playing, render the stepped frame
      if (!isPlaying) {
        var frameIdx = 0;
        for (var i = 0; i < frames.length; i++) {
          if (frames[i].time <= targetTime) {
            frameIdx = i;
          } else {
            break;
          }
        }
        currentIdx = frameIdx;
        
        video.onseeked = function() {
          video.onseeked = null;
          document.getElementById('timeDisplay').textContent = formatTime(video.currentTime) + '/' + formatTime(duration);
          document.getElementById('playhead').style.left = ((video.currentTime / duration) * 100) + '%';
          renderSteppedFrame(frameIdx);
          updateStructure();
        };
      }
    });
    document.getElementById('copyBtn').addEventListener('click', function() { 
      var btn = document.getElementById('copyBtn');
      navigator.clipboard.writeText(document.getElementById('exportData').textContent).then(function() {
        btn.textContent = 'Copied!'; 
        setTimeout(function() { btn.textContent = 'Copy JSON'; }, 1200);
      }); 
    });
    
    // === THEME TOGGLE ===
    const themeToggle = document.getElementById('themeToggle');
    const themeIcon = document.getElementById('themeIcon');
    const themeText = document.getElementById('themeText');
    const html = document.documentElement;
    
    // Check for saved theme preference or default to system preference
    const getPreferredTheme = () => {
      const savedTheme = localStorage.getItem('theme');
      if (savedTheme) {
        return savedTheme;
      }
      return window.matchMedia('(prefers-color-scheme: light)').matches ? 'light' : 'dark';
    };
    
    const setTheme = (theme) => {
      if (theme === 'light') {
        html.setAttribute('data-theme', 'light');
        themeIcon.textContent = '🌙';
        themeText.textContent = 'Dark';
      } else {
        html.removeAttribute('data-theme');
        themeIcon.textContent = '☀️';
        themeText.textContent = 'Light';
      }
      localStorage.setItem('theme', theme);
    };
    
    // Set initial theme
    setTheme(getPreferredTheme());
    
    // Toggle theme on button click
    themeToggle.addEventListener('click', () => {
      const currentTheme = html.getAttribute('data-theme');
      const newTheme = currentTheme === 'light' ? 'dark' : 'light';
      setTheme(newTheme);
    });
    
    // Listen for system theme changes
    window.matchMedia('(prefers-color-scheme: light)').addEventListener('change', (e) => {
      if (!localStorage.getItem('theme')) {
        setTheme(e.matches ? 'light' : 'dark');
      }
    });
  </script>
</body>
</html>

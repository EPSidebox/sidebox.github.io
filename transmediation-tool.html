<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Transmediator</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-8XQLL5N022"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-8XQLL5N022');
  </script>
<meta name="citation_title" content="Transmediator">
<meta name="citation_author" content="PeÃ±a, Ernesto">
<meta name="citation_publication_date" content="2026/01/10">
<meta name="citation_technical_report_institution" content="Northeastern University">
<meta name="citation_technical_report_number" content="v1.0">
<meta name="citation_abstract" content="A browser-based tool for exploring sensory, semiotic, and signal transmediation. Load audio, image, or text files and view raw data rendered simultaneously as text, pixels, and sound.">
<meta name="citation_keywords" content="transmediation; databending; glitch pedagogy; digital media; raw data">
<meta name="citation_public_url" content="https://epsidebox.github.io/sidebox.github.io/transmediation-tool.html">

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareApplication",
  "name": "Transmediator",
  "author": {
    "@type": "Person",
    "name": "Ernesto PeÃ±a",
    "affiliation": "Northeastern University",
    "url": "https://ernestopena.com"
  },
  "datePublished": "2026-01-10",
  "version": "1.0",
  "description": "A browser-based tool for exploring sensory, semiotic, and signal transmediation. Load audio, image, or text files and view raw data rendered simultaneously as text, pixels, and sound.",
  "url": "https://epsidebox.github.io/sidebox.github.io/transmediation-tool.html",
  "applicationCategory": "EducationalApplication",
  "operatingSystem": "Web browser",
  "keywords": ["transmediation", "databending", "glitch pedagogy", "digital media", "raw data"]
}
</script>
  <style>
    /* === BASE RESET === */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    /* === TYPOGRAPHY & COLORS === */
    :root {
      --font: 'Roboto Mono', monospace;
      --bg: #ffffff;
      --text: #000000;
      --accent: #FF00FF;
      --accent-secondary: #00bcd4;
      --accent-tertiary: #8bc34a;
      --muted: #999;
      --border: #eee;
      --panel-bg: #fafafa;
      --hover-bg: #f5f5f5;
      --hover-text: #000;
      --input-bg: #fafafa;
      --canvas-bg: #000;
      --waveform-bg: #fff;
    }
    
    [data-theme="dark"] {
      --bg: #0a0a0a;
      --text: #e0e0e0;
      --accent: #FF00FF;
      --accent-secondary: #00bcd4;
      --accent-tertiary: #8bc34a;
      --muted: #666;
      --border: #222;
      --panel-bg: #111;
      --hover-bg: #1a1a1a;
      --hover-text: #fff;
      --input-bg: #1a1a1a;
      --canvas-bg: #000;
      --waveform-bg: #0a0a0a;
    }
    
    body {
      font-family: 'Roboto Mono', monospace;
      background: var(--bg);
      color: var(--text);
      padding: clamp(1rem, 1rem + ((1vw - 0.48rem) * 0.288), 1.125rem);
      min-height: 100vh;
      line-height: 1.6;
      font-size: clamp(0.875rem, 0.875rem + ((1vw - 0.48rem) * 0.288), 1rem);
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    header {
      margin-bottom: clamp(1rem, 1rem + ((1vw - 0.48rem) * 0.288), 1.125rem);
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      flex-wrap: wrap;
      gap: 12px;
    }
    
    .header-content {
      flex: 1;
      min-width: 200px;
    }
    
    h1 {
      color: var(--accent);
      margin-bottom: 10px;
      font-size: clamp(1.75rem, 1.75rem + ((1vw - 0.48rem) * 0.288), 1.875rem);
      font-weight: 400;
      line-height: 1.2;
    }

    .subtitle {
      color: var(--muted);
      margin-bottom: 10px;
      font-size: clamp(0.8125rem, 0.8125rem + ((1vw - 0.48rem) * 0.144), 0.875rem);
      line-height: 1.5;
    }
    
    .theme-toggle {
      padding: 6px 12px;
      background: var(--panel-bg);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      cursor: pointer;
      font-family: inherit;
      font-size: clamp(0.625rem, 0.625rem + ((1vw - 0.48rem) * 0.072), 0.6563rem);
      transition: all 0.15s;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .theme-toggle:hover {
      border-color: var(--accent);
      background: var(--hover-bg);
    }
    
    .theme-toggle:focus {
      outline: 2px dashed var(--accent);
      outline-offset: 2px;
    }
    
    .main-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1.5rem;
      margin-bottom: 1.5rem;
    }
    
    .panel {
      background: var(--panel-bg);
      border: 1px solid var(--border);
      padding: 20px;
      border-radius: 6px;
      display: flex;
      flex-direction: column;
    }
    
    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    
    h2 {
      font-size: clamp(0.875rem, 0.875rem + ((1vw - 0.48rem) * 0.144), 0.9375rem);
      font-weight: 500;
      line-height: 1.4;
    }
    
    .controls {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      align-items: center;
    }
    
    select,
    button {
      font-family: 'Roboto Mono', monospace;
      font-size: clamp(0.625rem, 0.625rem + ((1vw - 0.48rem) * 0.072), 0.6563rem);
      padding: 0.25rem 0.5rem;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg);
      color: var(--text);
      cursor: pointer;
      transition: all 0.15s;
    }
    
    select:hover,
    button:hover {
      border-color: var(--accent);
    }
    
    select:focus,
    button:focus {
      outline: 2px dashed var(--accent);
      outline-offset: 2px;
    }
    
    button:active {
      transform: scale(0.98);
    }
    
    button.active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
    }
    
    .input-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      min-height: 400px;
    }
    
    .tab-bar {
      display: flex;
      gap: 0;
      border-bottom: 1px solid var(--border);
    }
    
    .tab {
      padding: 0.4rem 0.75rem;
      border: 1px solid var(--border);
      border-bottom: none;
      border-radius: 4px 4px 0 0;
      background: var(--hover-bg);
      cursor: pointer;
      font-size: clamp(0.625rem, 0.625rem + ((1vw - 0.48rem) * 0.072), 0.6563rem);
      margin-right: -1px;
      transition: all 0.15s;
    }
    
    .tab.active {
      background: var(--bg);
      border-bottom: 1px solid var(--bg);
      margin-bottom: -1px;
    }
    
    .tab:hover {
      color: var(--accent);
    }
    
    .tab:focus {
      outline: 2px dashed var(--accent);
      outline-offset: -2px;
    }
    
    textarea,
    .hex-editor {
      flex: 1;
      background: var(--input-bg);
      color: var(--text);
      border: 1px solid var(--border);
      border-top: none;
      border-radius: 0 0 0.5rem 0.5rem;
      padding: 0.75rem;
      font-family: 'Roboto Mono', monospace;
      font-size: clamp(0.6875rem, 0.6875rem + ((1vw - 0.48rem) * 0.144), 0.75rem);
      line-height: 1.6;
      resize: none;
      overflow-y: auto;
      transition: border-color 0.15s;
    }
    
    textarea:focus,
    .hex-editor:focus {
      outline: none;
      border-color: var(--accent);
      border-top-color: var(--border);
    }
    
    textarea::placeholder,
    .hex-editor::placeholder {
      color: var(--muted);
    }
    
    .hex-editor {
      white-space: pre-wrap;
      word-break: break-all;
    }
    
    .progress-bar {
      height: 6px;
      background: var(--hover-bg);
      border-radius: 4px;
      margin-top: 0.5rem;
      overflow: hidden;
    }
    
    .progress-fill {
      height: 100%;
      background: var(--accent);
      transition: width 0.1s;
    }
    
    .stats {
      display: flex;
      justify-content: space-between;
      font-size: clamp(0.625rem, 0.625rem + ((1vw - 0.48rem) * 0.072), 0.6563rem);
      color: var(--muted);
      margin-top: 0.25rem;
    }
    
    .stats .current {
      color: var(--accent);
    }
    
    .selection-info {
      font-size: clamp(0.5938rem, 0.5938rem + ((1vw - 0.48rem) * 0.072), 0.625rem);
      color: var(--accent);
      margin-top: 0.25rem;
      min-height: 1em;
    }
    
    .preview-section {
      margin-bottom: 1.5rem;
    }
    
    .preview-label {
      font-size: clamp(0.625rem, 0.625rem + ((1vw - 0.48rem) * 0.072), 0.6563rem);
      color: var(--muted);
      margin-bottom: 0.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    
    .canvas-wrapper {
      background: var(--canvas-bg);
      border-radius: 0.5rem;
      padding: 4px;
      display: inline-block;
      overflow: auto;
      max-width: 100%;
      max-height: 320px;
      border: 1px solid var(--border);
    }
    
    canvas#imageCanvas {
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    
    .zoom-controls {
      display: flex;
      gap: 0.25rem;
    }
    
    .zoom-btn {
      min-width: 2.5rem;
    }
    
    .waveform-container {
      background: var(--waveform-bg);
      border: 1px solid var(--border);
      border-radius: 0.5rem;
      padding: 0.5rem;
      width: 100%;
      max-height: 150px;
    }
    
    canvas#waveformCanvas {
      display: block;
      width: 100%;
      height: 100px;
    }
    
    .audio-controls {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
    }
    
    .play-btn {
      background: var(--accent);
      color: var(--bg);
      border: none;
      padding: 0.5rem 1rem;
      font-weight: 500;
      transition: all 0.15s;
    }
    
    .play-btn:hover {
      background: #cc00cc;
      transform: scale(1.02);
    }
    
    .play-btn:focus {
      outline: 2px dashed var(--accent);
      outline-offset: 2px;
    }
    
    .play-btn:active {
      transform: scale(0.98);
    }
    
    .download-btns {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
      flex-wrap: wrap;
      align-items: center;
    }
    
    .download-btns .separator {
      color: var(--border);
      margin: 0 0.25rem;
    }
    
    .upload-warning {
      font-size: clamp(0.625rem, 0.625rem + ((1vw - 0.48rem) * 0.072), 0.6563rem);
      color: #cc00cc;
      margin-top: 0.5rem;
      display: none;
      line-height: 1.4;
    }
    
    .upload-warning.visible {
      display: block;
    }
    
    .mode-toggle {
      display: flex;
      border: 1px solid var(--border);
      border-radius: 4px;
      overflow: hidden;
    }
    
    .mode-toggle button {
      border: none;
      border-radius: 0;
      border-right: 1px solid var(--border);
    }
    
    .mode-toggle button:last-child {
      border-right: none;
    }
    
    .encoding-info {
      font-size: clamp(0.5625rem, 0.5625rem + ((1vw - 0.48rem) * 0.072), 0.5938rem);
      color: var(--muted);
      margin-top: 0.25rem;
      line-height: 1.4;
    }
    
    .hidden {
      display: none !important;
    }
    
    footer {
      margin-top: clamp(1.5rem, 1.5rem + ((1vw - 0.48rem) * 1.442), 2rem);
      padding-top: 14px;
      border-top: 1px solid var(--border);
      font-size: clamp(0.625rem, 0.625rem + ((1vw - 0.48rem) * 0.072), 0.6563rem);
      color: var(--muted);
      text-align: center;
      line-height: 1.6;
    }

    footer a {
      color: var(--accent);
      text-decoration: underline;
      transition: all 0.15s;
    }
    
    footer a:hover {
      text-decoration: none;
      color: var(--hover-text);
    }
    
    footer a:focus {
      text-decoration: underline dashed;
      outline: 2px dashed var(--accent);
      outline-offset: 2px;
    }
    
    @media (max-width: 768px) {
      .main-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div class="header-content">
        <h1>Transmediator</h1>
        <p class="subtitle">Text â†’ Image â†’ Audio | 44,100 bytes = 210Ã—210 px = 1 second</p>
      </div>
      <button class="theme-toggle" id="themeToggle" aria-label="Toggle theme">
        <span id="themeIcon">ðŸŒ™</span>
        <span id="themeText">Dark</span>
      </button>
    </header>

    <div class="main-grid">
      <div class="panel">
        <div class="panel-header">
          <h2>Data Input</h2>
          <div class="controls">
            <div class="mode-toggle">
              <button id="grayBtn" class="active" onclick="setMode('gray')">Grayscale</button>
              <button id="rgbBtn" onclick="setMode('rgb')">RGB</button>
            </div>
          </div>
        </div>
        <div class="controls" style="margin-bottom:0.5rem;">
          <select id="encodingSelect" onchange="updatePreview()">
            <option value="unsigned">Unsigned (0â€“255)</option>
            <option value="signed">Signed (âˆ’128â€“127)</option>
          </select>
          <select id="interleavingSelect" onchange="updatePreview()" class="hidden">
            <option value="interleaved">Interleaved (RGBRGB...)</option>
            <option value="planar">Non-interleaved (RRR...GGG...BBB...)</option>
          </select>
          <button onclick="fillRandom()">Random bytes</button>
        </div>
        
        <div class="input-area">
          <div class="tab-bar">
            <div class="tab active" id="textTab" onclick="switchTab('text')">Text</div>
            <div class="tab" id="hexTab" onclick="switchTab('hex')">Hex</div>
          </div>
          <textarea id="editor" placeholder="Start typing or paste text..."></textarea>
          <textarea id="hexEditor" class="hex-editor hidden" placeholder="Enter hex values (e.g., 48 65 6C 6C 6F)..."></textarea>
        </div>
        
        <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
        <div class="stats">
          <span><span class="current" id="currentCount">0</span> / <span id="maxCount">44,100</span> bytes</span>
          <span id="remainingCount">44,100 remaining</span>
        </div>
        <div class="selection-info" id="selectionInfo"></div>
        <div class="download-btns">
          <button onclick="downloadFile('txt')">.txt</button>
          <button onclick="downloadFile('raw')">.raw</button>
          <span class="separator">|</span>
          <button onclick="document.getElementById('fileInput').click()">Upload file</button>
          <input type="file" id="fileInput" accept=".txt,.raw,.wav,.aiff,.aif,.au,.mp3,.ogg,.flac,.bmp,.png,.jpg,.jpeg,.gif,.tiff,.tif,.tga,.ppm,.pgm,.pbm,.md,.csv,.json,.xml,.html" style="display:none" onchange="handleFileUpload(event)">
        </div>
        <div class="upload-warning" id="uploadWarning"></div>
      </div>

      <div class="panel">
        <div class="preview-section">
          <div class="preview-label">
            <span>Image Preview (<span id="imageDims">210Ã—210 @ 1Ã—</span>)</span>
            <div class="zoom-controls">
              <button class="zoom-btn active" id="zoom1" onclick="setZoom(1)">1Ã—</button>
              <button class="zoom-btn" id="zoom2" onclick="setZoom(2)">2Ã—</button>
              <button class="zoom-btn" id="zoom4" onclick="setZoom(4)">4Ã—</button>
            </div>
            <button onclick="downloadImage()">Download PNG</button>
          </div>
          <div class="canvas-wrapper">
            <canvas id="imageCanvas" width="210" height="210"></canvas>
          </div>
          <div class="encoding-info" id="imageInfo">Unsigned: byte 0=black, 255=white</div>
        </div>

        <div class="preview-section">
          <div class="preview-label">
            <span>Audio Preview (<span id="audioDuration">1s</span> @ 44.1kHz 8-bit)</span>
          </div>
          <div class="waveform-container">
            <canvas id="waveformCanvas"></canvas>
          </div>
          <div class="encoding-info" id="audioInfo">Unsigned: 128=silence, 0/255=peaks</div>
          <div class="audio-controls">
            <button class="play-btn" id="playBtn" onclick="toggleAudio()">â–¶ Play</button>
            <button class="play-btn" id="playSelBtn" onclick="playSelection()" style="background:#cc00cc">â–¶ Selection</button>
            <button onclick="downloadAudio()">Download WAV</button>
          </div>
        </div>
      </div>
    </div>

    <footer>
      Transmediator â€” A Glitch Pedagogy Tool<br>
      Created by Ernesto PeÃ±a | <a href="https://ernestopena.com" target="_blank">ernestopena.com</a>
    </footer>
  </div>

  <script>
    const editor = document.getElementById('editor');
    const hexEditor = document.getElementById('hexEditor');
    const imageCanvas = document.getElementById('imageCanvas');
    const waveformCanvas = document.getElementById('waveformCanvas');
    const imgCtx = imageCanvas.getContext('2d');
    const waveCtx = waveformCanvas.getContext('2d');

    let mode = 'gray';
    let maxChars = 44100;
    let currentTab = 'text';
    let currentZoom = 1;
    let audioCtx = null;
    let sourceNode = null;
    let isPlaying = false;
    let rawBytes = new Uint8Array(0);
    let updatingFrom = null;
    let selection = { start: 0, end: 0 };

    // === THEME TOGGLE ===
    const themeToggle = document.getElementById('themeToggle');
    const themeIcon = document.getElementById('themeIcon');
    const themeText = document.getElementById('themeText');
    const html = document.documentElement;
    
    const getPreferredTheme = () => {
      const savedTheme = localStorage.getItem('theme');
      if (savedTheme) return savedTheme;
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    
    const setTheme = (theme) => {
      if (theme === 'dark') {
        html.setAttribute('data-theme', 'dark');
        themeIcon.textContent = 'â˜€ï¸';
        themeText.textContent = 'Light';
      } else {
        html.removeAttribute('data-theme');
        themeIcon.textContent = 'ðŸŒ™';
        themeText.textContent = 'Dark';
      }
      localStorage.setItem('theme', theme);
      updatePreview();
    };
    
    setTheme(getPreferredTheme());
    
    themeToggle.addEventListener('click', () => {
      const currentTheme = html.getAttribute('data-theme');
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
      setTheme(newTheme);
    });
    
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
      if (!localStorage.getItem('theme')) {
        setTheme(e.matches ? 'dark' : 'light');
      }
    });

    function setMode(m) {
      mode = m;
      maxChars = m === 'gray' ? 44100 : 132300;
      document.getElementById('grayBtn').classList.toggle('active', m === 'gray');
      document.getElementById('rgbBtn').classList.toggle('active', m === 'rgb');
      document.getElementById('interleavingSelect').classList.toggle('hidden', m === 'gray');
      document.getElementById('maxCount').textContent = maxChars.toLocaleString();
      document.getElementById('audioDuration').textContent = m === 'gray' ? '1s' : '3s';
      if (rawBytes.length > maxChars) {
        rawBytes = rawBytes.slice(0, maxChars);
        syncFromBytes();
      }
      updatePreview();
    }

    function setZoom(z) {
      currentZoom = z;
      document.querySelectorAll('.zoom-btn').forEach(b => b.classList.remove('active'));
      document.getElementById('zoom' + z).classList.add('active');
      const size = 210 * z;
      imageCanvas.style.width = size + 'px';
      imageCanvas.style.height = size + 'px';
      document.getElementById('imageDims').textContent = `210Ã—210 @ ${z}Ã—`;
    }

    function switchTab(tab) {
      currentTab = tab;
      document.getElementById('textTab').classList.toggle('active', tab === 'text');
      document.getElementById('hexTab').classList.toggle('active', tab === 'hex');
      editor.classList.toggle('hidden', tab !== 'text');
      hexEditor.classList.toggle('hidden', tab !== 'hex');
    }

    function textToBytes(text) {
      const bytes = new Uint8Array(text.length);
      for (let i = 0; i < text.length; i++) bytes[i] = text.charCodeAt(i) & 0xFF;
      return bytes;
    }

    function bytesToText(bytes) {
      let t = '';
      for (let i = 0; i < bytes.length; i++) t += String.fromCharCode(bytes[i]);
      return t;
    }

    function bytesToHex(bytes) {
      let hex = '';
      for (let i = 0; i < bytes.length; i++) {
        hex += bytes[i].toString(16).padStart(2, '0').toUpperCase();
        if ((i + 1) % 16 === 0) hex += '\n';
        else if (i < bytes.length - 1) hex += ' ';
      }
      return hex;
    }

    function hexToBytes(hex) {
      const clean = hex.replace(/[^0-9A-Fa-f]/g, '');
      const bytes = new Uint8Array(Math.floor(clean.length / 2));
      for (let i = 0; i < bytes.length; i++) bytes[i] = parseInt(clean.substr(i * 2, 2), 16);
      return bytes;
    }

    function syncFromBytes() {
      if (updatingFrom === 'text') {
        hexEditor.value = bytesToHex(rawBytes);
      } else if (updatingFrom === 'hex') {
        editor.value = bytesToText(rawBytes);
      } else {
        editor.value = bytesToText(rawBytes);
        hexEditor.value = bytesToHex(rawBytes);
      }
    }

    function getBytes() {
      const padded = new Uint8Array(maxChars);
      padded.set(rawBytes.slice(0, maxChars));
      return padded;
    }

    function handleTextInput() {
      updatingFrom = 'text';
      let text = editor.value;
      if (text.length > maxChars) {
        text = text.substring(0, maxChars);
        editor.value = text;
      }
      rawBytes = textToBytes(text);
      syncFromBytes();
      updatingFrom = null;
      updatePreview();
    }

    function handleHexInput() {
      updatingFrom = 'hex';
      let bytes = hexToBytes(hexEditor.value);
      if (bytes.length > maxChars) bytes = bytes.slice(0, maxChars);
      rawBytes = bytes;
      syncFromBytes();
      updatingFrom = null;
      updatePreview();
    }

    function handleSelection() {
      let start, end;
      if (currentTab === 'text') {
        start = editor.selectionStart;
        end = editor.selectionEnd;
      } else {
        const hexStart = hexEditor.selectionStart;
        const hexEnd = hexEditor.selectionEnd;
        const beforeStart = hexEditor.value.substring(0, hexStart).replace(/[^0-9A-Fa-f]/g, '');
        const beforeEnd = hexEditor.value.substring(0, hexEnd).replace(/[^0-9A-Fa-f]/g, '');
        start = Math.floor(beforeStart.length / 2);
        end = Math.floor(beforeEnd.length / 2);
      }
      
      selection = { start: Math.min(start, end), end: Math.max(start, end) };
      updateSelectionInfo();
      updatePreview();
    }

    function updateSelectionInfo() {
      const info = document.getElementById('selectionInfo');
      if (selection.start === selection.end) {
        info.textContent = '';
        return;
      }
      const len = selection.end - selection.start;
      const startPx = Math.floor(selection.start / (mode === 'rgb' ? 3 : 1));
      const endPx = Math.ceil(selection.end / (mode === 'rgb' ? 3 : 1));
      const startTime = (selection.start / 44100).toFixed(4);
      const endTime = (selection.end / 44100).toFixed(4);
      info.textContent = `Selected: bytes ${selection.start}â€“${selection.end} (${len}) | pixels ${startPx}â€“${endPx} | audio ${startTime}sâ€“${endTime}s`;
    }

    function fillRandom() {
      rawBytes = new Uint8Array(maxChars);
      for (let i = 0; i < maxChars; i++) rawBytes[i] = Math.floor(Math.random() * 256);
      syncFromBytes();
      updatePreview();
    }

    editor.addEventListener('input', handleTextInput);
    hexEditor.addEventListener('input', handleHexInput);
    editor.addEventListener('select', handleSelection);
    editor.addEventListener('click', handleSelection);
    editor.addEventListener('keyup', handleSelection);
    hexEditor.addEventListener('select', handleSelection);
    hexEditor.addEventListener('click', handleSelection);
    hexEditor.addEventListener('keyup', handleSelection);

    editor.addEventListener('paste', function(e) {
      e.preventDefault();
      const paste = (e.clipboardData || window.clipboardData).getData('text');
      const start = this.selectionStart;
      const end = this.selectionEnd;
      const before = this.value.substring(0, start);
      const after = this.value.substring(end);
      const available = maxChars - (this.value.length - (end - start));
      const truncated = paste.substring(0, Math.max(0, available));
      this.value = before + truncated + after;
      this.selectionStart = this.selectionEnd = start + truncated.length;
      handleTextInput();
    });

    function updateImage() {
      const bytes = getBytes();
      const encoding = document.getElementById('encodingSelect').value;
      const interleaving = document.getElementById('interleavingSelect').value;
      const imgData = imgCtx.createImageData(210, 210);

      if (mode === 'gray') {
        for (let i = 0; i < 44100; i++) {
          let val = bytes[i];
          if (encoding === 'signed') val = ((val < 128 ? val : val - 256) + 128);
          const idx = i * 4;
          imgData.data[idx] = val;
          imgData.data[idx + 1] = val;
          imgData.data[idx + 2] = val;
          imgData.data[idx + 3] = 255;
        }
        document.getElementById('imageInfo').textContent = encoding === 'unsigned'
          ? 'Unsigned: byte 0=black, 255=white'
          : 'Signed: -128â†’0 (black), 0â†’128 (gray), 127â†’255 (white)';
      } else {
        for (let i = 0; i < 44100; i++) {
          let r, g, b;
          if (interleaving === 'interleaved') {
            r = bytes[i * 3] || 0;
            g = bytes[i * 3 + 1] || 0;
            b = bytes[i * 3 + 2] || 0;
          } else {
            r = bytes[i] || 0;
            g = bytes[44100 + i] || 0;
            b = bytes[88200 + i] || 0;
          }
          if (encoding === 'signed') {
            r = ((r < 128 ? r : r - 256) + 128);
            g = ((g < 128 ? g : g - 256) + 128);
            b = ((b < 128 ? b : b - 256) + 128);
          }
          const idx = i * 4;
          imgData.data[idx] = r;
          imgData.data[idx + 1] = g;
          imgData.data[idx + 2] = b;
          imgData.data[idx + 3] = 255;
        }
        document.getElementById('imageInfo').textContent = encoding === 'unsigned'
          ? `Unsigned RGB (${interleaving}): 0=none, 255=full per channel`
          : `Signed RGB (${interleaving}): -128â†’0, 127â†’255 per channel`;
      }
      imgCtx.putImageData(imgData, 0, 0);

      if (selection.start !== selection.end) {
        imgCtx.fillStyle = 'rgba(255, 0, 255, 0.4)';
        const interl = document.getElementById('interleavingSelect').value;
        
        if (mode === 'gray') {
          for (let i = selection.start; i < selection.end && i < 44100; i++) {
            const x = i % 210;
            const y = Math.floor(i / 210);
            imgCtx.fillRect(x, y, 1, 1);
          }
        } else if (interl === 'interleaved') {
          const startPx = Math.floor(selection.start / 3);
          const endPx = Math.ceil(selection.end / 3);
          for (let i = startPx; i < endPx && i < 44100; i++) {
            const x = i % 210;
            const y = Math.floor(i / 210);
            imgCtx.fillRect(x, y, 1, 1);
          }
        } else {
          for (let i = selection.start; i < selection.end && i < 132300; i++) {
            let px;
            if (i < 44100) px = i;
            else if (i < 88200) px = i - 44100;
            else px = i - 88200;
            const x = px % 210;
            const y = Math.floor(px / 210);
            imgCtx.fillRect(x, y, 1, 1);
          }
        }
      }
    }

    function updateWaveform() {
      const bytes = getBytes();
      const encoding = document.getElementById('encodingSelect').value;
      const w = waveformCanvas.width = waveformCanvas.offsetWidth * 2;
      const h = waveformCanvas.height = 200;
      const samples = mode === 'gray' ? 44100 : 132300;
      
      const isDark = html.getAttribute('data-theme') === 'dark';
      const waveformBg = isDark ? '#0a0a0a' : '#fff';
      const gridColor = isDark ? '#222' : '#eee';

      waveCtx.fillStyle = waveformBg;
      waveCtx.fillRect(0, 0, w, h);

      if (selection.start !== selection.end) {
        const startX = (selection.start / samples) * w;
        const endX = (selection.end / samples) * w;
        waveCtx.fillStyle = 'rgba(255, 0, 255, 0.2)';
        waveCtx.fillRect(startX, 0, endX - startX, h);
      }

      waveCtx.strokeStyle = gridColor;
      waveCtx.lineWidth = 1;
      waveCtx.beginPath();
      waveCtx.moveTo(0, h / 2);
      waveCtx.lineTo(w, h / 2);
      waveCtx.stroke();

      waveCtx.strokeStyle = '#FF00FF';
      waveCtx.lineWidth = 1.5;
      waveCtx.beginPath();

      for (let x = 0; x < w; x++) {
        const i = Math.floor(x * samples / w);
        let val = bytes[i] || (encoding === 'unsigned' ? 128 : 0);
        let normalized = encoding === 'unsigned' ? (val - 128) / 128 : (val < 128 ? val : val - 256) / 128;
        const y = h / 2 - normalized * (h / 2 - 10);
        x === 0 ? waveCtx.moveTo(x, y) : waveCtx.lineTo(x, y);
      }
      waveCtx.stroke();

      document.getElementById('audioInfo').textContent = encoding === 'unsigned'
        ? 'Unsigned: 128=silence, 0/255=peaks'
        : 'Signed: 0=silence, -128/127=peaks';
    }

    function updateStats() {
      const len = rawBytes.length;
      const pct = (len / maxChars) * 100;
      document.getElementById('progressFill').style.width = Math.min(pct, 100) + '%';
      document.getElementById('currentCount').textContent = len.toLocaleString();
      document.getElementById('remainingCount').textContent = (maxChars - len).toLocaleString() + ' remaining';
    }

    function updatePreview() {
      updateStats();
      updateImage();
      updateWaveform();
    }

    function toggleAudio() { isPlaying ? stopAudio() : playAudio(); }

    function playAudio() {
      const bytes = getBytes();
      const encoding = document.getElementById('encodingSelect').value;
      const sampleRate = 44100;
      const numSamples = mode === 'gray' ? 44100 : 132300;

      audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate });
      const buffer = audioCtx.createBuffer(1, numSamples, sampleRate);
      const channel = buffer.getChannelData(0);

      for (let i = 0; i < numSamples; i++) {
        let val = bytes[i] || (encoding === 'unsigned' ? 128 : 0);
        channel[i] = encoding === 'unsigned' ? (val - 128) / 128 : (val < 128 ? val : val - 256) / 128;
      }

      sourceNode = audioCtx.createBufferSource();
      sourceNode.buffer = buffer;
      sourceNode.connect(audioCtx.destination);
      sourceNode.onended = stopAudio;
      sourceNode.start();
      isPlaying = true;
      document.getElementById('playBtn').textContent = 'â—¼ Stop';
    }

    function stopAudio() {
      if (sourceNode) { sourceNode.stop(); sourceNode.disconnect(); }
      if (audioCtx) audioCtx.close();
      isPlaying = false;
      document.getElementById('playBtn').textContent = 'â–¶ Play';
      document.getElementById('playSelBtn').textContent = 'â–¶ Selection';
    }

    function playSelection() {
      if (isPlaying) { stopAudio(); return; }
      if (selection.start === selection.end) { alert('No selection'); return; }
      
      const bytes = getBytes();
      const encoding = document.getElementById('encodingSelect').value;
      const sampleRate = 44100;
      const numSamples = selection.end - selection.start;

      audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate });
      const buffer = audioCtx.createBuffer(1, numSamples, sampleRate);
      const channel = buffer.getChannelData(0);

      for (let i = 0; i < numSamples; i++) {
        let val = bytes[selection.start + i] || (encoding === 'unsigned' ? 128 : 0);
        channel[i] = encoding === 'unsigned' ? (val - 128) / 128 : (val < 128 ? val : val - 256) / 128;
      }

      sourceNode = audioCtx.createBufferSource();
      sourceNode.buffer = buffer;
      sourceNode.connect(audioCtx.destination);
      sourceNode.onended = stopAudio;
      sourceNode.start();
      isPlaying = true;
      document.getElementById('playSelBtn').textContent = 'â—¼ Stop';
    }

    function downloadFile(ext) {
      if (!rawBytes.length) return alert('Nothing to download');
      const blob = ext === 'raw'
        ? new Blob([rawBytes], { type: 'application/octet-stream' })
        : new Blob([bytesToText(rawBytes)], { type: 'text/plain' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'data-' + Date.now() + '.' + ext;
      a.click();
      URL.revokeObjectURL(a.href);
    }

    function downloadImage() {
      const a = document.createElement('a');
      a.href = imageCanvas.toDataURL('image/png');
      a.download = 'image-' + Date.now() + '.png';
      a.click();
    }

    function downloadAudio() {
      const bytes = getBytes();
      const encoding = document.getElementById('encodingSelect').value;
      const numSamples = mode === 'gray' ? 44100 : 132300;
      const sampleRate = 44100;

      const wavBuffer = new ArrayBuffer(44 + numSamples);
      const view = new DataView(wavBuffer);
      const writeStr = (o, s) => { for (let i = 0; i < s.length; i++) view.setUint8(o + i, s.charCodeAt(i)); };

      writeStr(0, 'RIFF');
      view.setUint32(4, 36 + numSamples, true);
      writeStr(8, 'WAVE');
      writeStr(12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, 1, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate, true);
      view.setUint16(32, 1, true);
      view.setUint16(34, 8, true);
      writeStr(36, 'data');
      view.setUint32(40, numSamples, true);

      for (let i = 0; i < numSamples; i++) {
        let val = bytes[i] || (encoding === 'unsigned' ? 128 : 0);
        if (encoding === 'signed') val = ((val < 128 ? val : val - 256) + 128);
        view.setUint8(44 + i, val);
      }

      const blob = new Blob([wavBuffer], { type: 'audio/wav' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'audio-' + Date.now() + '.wav';
      a.click();
      URL.revokeObjectURL(a.href);
    }

    function handleFileUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const warning = document.getElementById('uploadWarning');
      const reader = new FileReader();

      reader.onload = function(e) {
        let bytes = new Uint8Array(e.target.result);
        const originalLength = bytes.length;

        if (bytes.length > maxChars) {
          bytes = bytes.slice(0, maxChars);
          warning.textContent = `File truncated: ${originalLength.toLocaleString()} bytes â†’ ${maxChars.toLocaleString()} bytes (limit reached)`;
          warning.classList.add('visible');
        } else {
          warning.textContent = `Loaded ${bytes.length.toLocaleString()} bytes from ${file.name}`;
          warning.classList.add('visible');
        }

        rawBytes = bytes;
        syncFromBytes();
        updatePreview();
        setTimeout(() => warning.classList.remove('visible'), 5000);
      };

      reader.readAsArrayBuffer(file);
      event.target.value = '';
    }

    updatePreview();
  </script>
</body>
</html>
